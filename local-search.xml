<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring Bean Basic</title>
    <link href="/2020/04/20/Spring-Bean-Basic/"/>
    <url>/2020/04/20/Spring-Bean-Basic/</url>
    
    <content type="html"><![CDATA[<!-- # Spring Bean 基础 --><h2 id="定义Spring-Bean"><a href="#定义Spring-Bean" class="headerlink" title="定义Spring Bean"></a>定义Spring Bean</h2><p>BeanDefinition 是Spring Framework 中定义Bean 的配置元信息接口，包含：</p><ul><li>Bean 的类名</li><li>Bean 行为配置元素，如作用域、自动绑定的模式，生命周期回调等</li><li>其他Bean 引用，又可称作合作者（collaborators）或者依赖（dependencies）</li><li>配置设置，比如Bean 属性（Properties）</li></ul><h2 id="BeanDefinition-元信息"><a href="#BeanDefinition-元信息" class="headerlink" title="BeanDefinition 元信息"></a>BeanDefinition 元信息</h2><table><thead><tr><th align="left">属性（Property）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Class</td><td align="left">Bean 全类名，必须是具体类，不能用抽象类或接口</td></tr><tr><td align="left">Name</td><td align="left">Bean 的名称或者ID</td></tr><tr><td align="left">Scope</td><td align="left">Bean 的作用域（如：singleton、prototype 等）</td></tr><tr><td align="left">Constructor arguments</td><td align="left">Bean 构造器参数（用于依赖注入）</td></tr><tr><td align="left">Properties</td><td align="left">Bean 属性设置（用于依赖注入）</td></tr><tr><td align="left">Autowiring mode</td><td align="left">Bean 自动绑定模式（如：通过名称byName）</td></tr><tr><td align="left">Lazy initialization mode</td><td align="left">Bean 延迟初始化模式（延迟和非延迟）</td></tr><tr><td align="left">Initialization method</td><td align="left">Bean 初始化回调方法名称</td></tr><tr><td align="left">Destruction method</td><td align="left">Bean 销毁回调方法名称</td></tr></tbody></table><h2 id="BeanDefinition的创建"><a href="#BeanDefinition的创建" class="headerlink" title="BeanDefinition的创建"></a>BeanDefinition的创建</h2><h3 id="通过-BeanDefinitionBuilder-构建"><a href="#通过-BeanDefinitionBuilder-构建" class="headerlink" title="通过 BeanDefinitionBuilder 构建"></a>通过 BeanDefinitionBuilder 构建</h3><pre><code class="hljs java">BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">// 通过属性设置</span>beanDefinitionBuilder.addPropertyValue(<span class="hljs-string">"id"</span>, <span class="hljs-number">1</span>).addPropertyValue(<span class="hljs-string">"name"</span>, <span class="hljs-string">"John"</span>);<span class="hljs-comment">// 获取 BeanDefinition 实例</span>BeanDefinition beanDefinition = beanDefinitionBuilder.getBeanDefinition();<span class="hljs-comment">// BeanDefinition 并非 Bean 终态，可以自定义修改</span></code></pre><h3 id="通过-AbstractBeanDefinition-以及派生类"><a href="#通过-AbstractBeanDefinition-以及派生类" class="headerlink" title="通过 AbstractBeanDefinition 以及派生类"></a>通过 AbstractBeanDefinition 以及派生类</h3><pre><code class="hljs java">GenericBeanDefinition genericBeanDefinition = <span class="hljs-keyword">new</span> GenericBeanDefinition();<span class="hljs-comment">// 设置 Bean 类型</span>genericBeanDefinition.setBeanClass(User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">// 通过 MutablePropertyValues 批量操作属性</span>MutablePropertyValues propertyValues = <span class="hljs-keyword">new</span> MutablePropertyValues();propertyValues.add(<span class="hljs-string">"id"</span>, <span class="hljs-number">1</span>).add(<span class="hljs-string">"name"</span>, <span class="hljs-string">"John"</span>);<span class="hljs-comment">// 通过 set MutablePropertyValues 批量操作属性</span>genericBeanDefinition.setPropertyValues(propertyValues);</code></pre><h2 id="命名Spring-Bean"><a href="#命名Spring-Bean" class="headerlink" title="命名Spring Bean"></a>命名Spring Bean</h2><h3 id="Bean-的名称"><a href="#Bean-的名称" class="headerlink" title="Bean 的名称"></a>Bean 的名称</h3><p>每个Bean 拥有一个或多个标识符（identifiers），这些标识符在Bean 所在的容器必须是唯一的。通常，一个Bean 仅有一个标识符，如果需要额外的，可考虑使用别名（Alias）来扩充。</p><p>在基于XML 的配置元信息（并不仅限于xml文件，包括其他方式来配置xml配置元信息）中，开发人员可用id 或者name 属性来规定Bean 的标识符。通常Bean 的标识符由字母组成，允许出现特殊字符。如果要想引入Bean 的别名的话，可在name 属性使用半角逗号（“,”）或分号（“;”) 来间隔。</p><p>Bean 的id 或name 属性并非必须制定，如果留空的话，容器会为Bean 自动生成一个唯一的名称。Bean 的命名尽管没有限制，不过官方建议采用驼峰的方式，更符合Java 的命名约定。</p><h3 id="Bean-名称生成器（BeanNameGenerator）"><a href="#Bean-名称生成器（BeanNameGenerator）" class="headerlink" title="Bean 名称生成器（BeanNameGenerator）"></a>Bean 名称生成器（BeanNameGenerator）</h3><p>由Spring Framework 2.0.3 引入，框架內建两种实现：</p><ul><li><p>DefaultBeanNameGenerator：默认通用BeanNameGenerator 实现；</p></li><li><p>AnnotationBeanNameGenerator：基于注解扫描的BeanNameGenerator 实现，起始于Spring Framework 2.5:</p><p>With component scanning in the classpath, Spring generates bean names for unnamed components, following the rules described earlier: essentially, taking the simple class name and turning its initial character to lower-case. However, in the (unusual) special case when there is more than one character and both the first and second characters are upper case, the original casing gets preserved.<br>These are the same rules as defined by java.beans.Introspector.decapitalize (which Spring uses here).</p></li></ul><h4 id="BeanNameGenerator"><a href="#BeanNameGenerator" class="headerlink" title="BeanNameGenerator"></a>BeanNameGenerator</h4><p>源代码<code>org.springframework.beans.factory.support.BeanNameGenerator</code>：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanNameGenerator</span> </span>&#123;<span class="hljs-function">String <span class="hljs-title">generateBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span></span>;&#125;</code></pre><h4 id="DefaultBeanNameGenerator"><a href="#DefaultBeanNameGenerator" class="headerlink" title="DefaultBeanNameGenerator"></a>DefaultBeanNameGenerator</h4><p><code>org.springframework.beans.factory.support.DefaultBeanNameGenerator</code>:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultBeanNameGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanNameGenerator</span> </span>&#123;<span class="hljs-comment">// 共有API，要继承旧版本，因此构造函数必须为public</span>    <span class="hljs-comment">// 使用单例模式进行实现，以节约资源。</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultBeanNameGenerator INSTANCE = <span class="hljs-keyword">new</span> DefaultBeanNameGenerator();<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">generateBeanName</span><span class="hljs-params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;<span class="hljs-keyword">return</span> BeanDefinitionReaderUtils.generateBeanName(definition, registry);&#125;&#125;</code></pre><h2 id="Spring-Bean-的别名"><a href="#Spring-Bean-的别名" class="headerlink" title="Spring Bean 的别名"></a>Spring Bean 的别名</h2><h3 id="Bean-别名（Alias）的价值"><a href="#Bean-别名（Alias）的价值" class="headerlink" title="Bean 别名（Alias）的价值"></a>Bean 别名（Alias）的价值</h3><ul><li><p>复用现有的BeanDefinition</p></li><li><p>更具有场景化的命名方法，比如：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myApp-dataSource"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"subsystemA-dataSource"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myApp-dataSource"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"subsystemB-dataSource"</span>/&gt;</span></code></pre></li></ul><h4 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h4><h5 id="xml-配置"><a href="#xml-配置" class="headerlink" title="xml 配置"></a>xml 配置</h5><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 导入第三方 Spring XML 配置文件 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"classpath:/META-INF/dependency-lookup-context.xml"</span> /&gt;</span><span class="hljs-comment">&lt;!-- 将 Spring 容器中 "user" Bean 关联/建立别名 - "xiaomage-user" --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">"xiaomage-user"</span> /&gt;</span></code></pre><h5 id="Java使用"><a href="#Java使用" class="headerlink" title="Java使用"></a>Java使用</h5><pre><code class="hljs java"><span class="hljs-comment">// 配置 XML 配置文件</span><span class="hljs-comment">// 启动 Spring 应用上下文</span>BeanFactory beanFactory = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:/META-INF/bean-definitions-context.xml"</span>);<span class="hljs-comment">// 通过别名 xiaomage-user 获取曾用名 user 的 bean</span>User user = beanFactory.getBean(<span class="hljs-string">"user"</span>, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;User xiaomageUser = beanFactory.getBean(<span class="hljs-string">"xiaomage-user"</span>, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;System.out.println(<span class="hljs-string">"xiaomage-user 是否与 user Bean 相同："</span> + (user == xiaomageUser));</code></pre><p>运行结果为</p><pre><code class="hljs bash">xiaomage-user 是否与 user Bean 相同：<span class="hljs-literal">true</span></code></pre><h2 id="注册Spring-Bean"><a href="#注册Spring-Bean" class="headerlink" title="注册Spring Bean"></a>注册Spring Bean</h2><p>  BeanDefinition 注册</p><h3 id="XML-配置元信息"><a href="#XML-配置元信息" class="headerlink" title="XML 配置元信息"></a>XML 配置元信息</h3><p><code>&lt;bean name=”...” ... /&gt;</code></p><h3 id="Java-注解配置元信息"><a href="#Java-注解配置元信息" class="headerlink" title="Java 注解配置元信息"></a>Java 注解配置元信息</h3><h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>&#123;    <span class="hljs-comment">// 1. 通过 @Bean 方式定义</span>    <span class="hljs-comment">// 通过 Java 注解的方式，定义了一个 Bean</span>    <span class="hljs-meta">@Bean</span>(name = &#123;<span class="hljs-string">"user"</span>, <span class="hljs-string">"xiaomage-user"</span>&#125;) <span class="hljs-comment">// Bean的 name 配置为可选项</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setId(<span class="hljs-number">1L</span>);        user.setName(<span class="hljs-string">"John"</span>);        <span class="hljs-keyword">return</span> user;    &#125;&#125;</code></pre><h4 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>在Config类上增加<code>@Component</code>注解，定义当前类为Spring Bean（组件）</p><pre><code class="hljs java"><span class="hljs-comment">// 2. 通过 @Component 方式</span><span class="hljs-meta">@Component</span> <span class="hljs-comment">// 定义当前类作为 Spring Bean（组件）</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>&#123;    <span class="hljs-comment">// 通过 Java 注解的方式，定义了一个 Bean</span>    <span class="hljs-meta">@Bean</span>(name = &#123;<span class="hljs-string">"user"</span>, <span class="hljs-string">"xiaomage-user"</span>&#125;) <span class="hljs-comment">// Bean的 name 配置为可选项</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setId(<span class="hljs-number">1L</span>);        user.setName(<span class="hljs-string">"John"</span>);        <span class="hljs-keyword">return</span> user;    &#125;&#125;</code></pre><h4 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h4><p>在主类上通过使用<code>@Import</code>进行引入。</p><pre><code class="hljs java"><span class="hljs-comment">// 3. 通过 @Import 来进行导入</span><span class="hljs-meta">@Import</span>(AnnotationBeanDefinitionDemo.Config<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">AnnotationBeanDefinitionDemo</span> </span>&#123;    <span class="hljs-comment">// 省略内容……</span>&#125;</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>上述通过三种不同的方法定义了bean: <code>User</code>，<code>Config</code>和<code>Component</code>。那么，<code>Config</code>和<code>Component</code>都定义了bean，是否会生成不同的Bean呢？</p><p>下面的代码可以显示<code>AnnotationBeanDefinitionDemo</code>， <code>Config</code>和<code>User</code>着三个Bean是否有重复注册。</p><pre><code class="hljs java"><span class="hljs-comment">// 创建 BeanFactory 容器</span>AnnotationConfigApplicationContext applicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<span class="hljs-comment">// 注册 Configuration Class（配置类）</span>applicationContext.register(AnnotationBeanDefinitionDemo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">// 启动 Spring 应用上下文</span>applicationContext.refresh();<span class="hljs-comment">// 按照类型依赖查找</span>System.out.println(<span class="hljs-string">"Config 类型的所有 Beans： "</span> + applicationContext.getBeansOfType(Config<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;System.out.println(<span class="hljs-string">"User 类型的所有 Beans： "</span> + applicationContext.getBeansOfType(User<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;<span class="hljs-comment">// 显式地关闭 Spring 应用上下文</span>applicationContext.close();&#125;</code></pre><p>输出结果为：</p><pre><code class="hljs shell">Config 类型的所有 Beans： &#123;bean.definition.AnnotationBeanDefinitionDemo$Config=bean.definition.AnnotationBeanDefinitionDemo$Config@f6efaab&#125;User 类型的所有 Beans： &#123;user=User&#123;id=1, name='John'&#125;&#125;</code></pre><p><strong>Config只有一个，User也只有一个。就是说，在Spring容器中，不会进行重复注册。</strong></p><h3 id="Java-API-配置元信息"><a href="#Java-API-配置元信息" class="headerlink" title="Java API 配置元信息"></a>Java API 配置元信息</h3><h4 id="命名方式"><a href="#命名方式" class="headerlink" title="命名方式"></a>命名方式</h4><p> <code>BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerUserBeanDefinition</span><span class="hljs-params">(BeanDefinitionRegistry registry, String beanName)</span> </span>&#123;    BeanDefinitionBuilder beanDefinitionBuilder = genericBeanDefinition(User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    beanDefinitionBuilder        .addPropertyValue(<span class="hljs-string">"id"</span>, <span class="hljs-number">1L</span>)        .addPropertyValue(<span class="hljs-string">"name"</span>, <span class="hljs-string">"John"</span>);    <span class="hljs-comment">// 判断如果 beanName 参数存在时</span>    <span class="hljs-keyword">if</span> (StringUtils.hasText(beanName)) &#123;        <span class="hljs-comment">// 注册 BeanDefinition</span>        registry.registerBeanDefinition(beanName, beanDefinitionBuilder.getBeanDefinition());    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 非命名 Bean 注册方法</span>        BeanDefinitionReaderUtils.registerWithGeneratedName(beanDefinitionBuilder.getBeanDefinition(), registry);    &#125;&#125;</code></pre><h4 id="非命名方式"><a href="#非命名方式" class="headerlink" title="非命名方式"></a>非命名方式</h4><p><code>BeanDefinitionReaderUtils#registerWithGeneratedName(AbstractBeanDefinition,BeanDefinitionRegistry)</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerUserBeanDefinition</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;    registerUserBeanDefinition(registry, <span class="hljs-keyword">null</span>);&#125;</code></pre><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><pre><code class="hljs java"><span class="hljs-comment">// 通过 BeanDefinition 注册 API 实现</span><span class="hljs-comment">// 1.命名 Bean 的注册方式</span>registerUserBeanDefinition(applicationContext, <span class="hljs-string">"mercyblitz-user"</span>);<span class="hljs-comment">// 2. 非命名 Bean 的注册方法</span>registerUserBeanDefinition(applicationContext);</code></pre><p><strong>命名 Bean 的注册方式</strong> 的输出为：</p><pre><code class="hljs shell">User 类型的所有 Beans&#123;mercyblitz-user=User&#123;id=1, name='John'&#125;&#125;</code></pre><p><strong>非命名 Bean 的注册方式</strong> 的输出为：</p><pre><code class="hljs shell">User 类型的所有 Beans&#123;ioc.overview.domain.User#0=User&#123;id=1, name='John'&#125;&#125;</code></pre><p>如果将上述3中方式一起使用，则输出为：</p><pre><code class="hljs shell">User 类型的所有 Beans&#123;mercyblitz-user=User&#123;id=1, name='John'&#125;, ioc.overview.domain.User#0=User&#123;id=1, name='John'&#125;, user=User&#123;id=1, name='John'&#125;&#125;</code></pre><h4 id="配置类方式"><a href="#配置类方式" class="headerlink" title="配置类方式"></a>配置类方式</h4><p> <code>AnnotatedBeanDefinitionReader#register(Class...)</code></p><p>该方式之前已经使用过，代码为：</p><pre><code class="hljs java"><span class="hljs-comment">// 注册 Configuration Class（配置类）</span>applicationContext.register(AnnotationBeanDefinitionDemo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre><h2 id="实例化Spring-Bean-Bean-实例化（Instantiation）"><a href="#实例化Spring-Bean-Bean-实例化（Instantiation）" class="headerlink" title="实例化Spring Bean - Bean 实例化（Instantiation）"></a>实例化Spring Bean - Bean 实例化（Instantiation）</h2><h3 id="常规方式"><a href="#常规方式" class="headerlink" title="常规方式"></a>常规方式</h3><p>配置<code>META-INF/bean-instantiation-context.xml</code>：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 静态方法实例化 Bean --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user-by-static-method"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ioc.overview.domain.User"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createUser"</span>/&gt;</span><span class="hljs-comment">&lt;!-- 实例（Bean）方法实例化 Bean --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user-by-instance-method"</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">"userFactory"</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">"createUser"</span>/&gt;</span><span class="hljs-comment">&lt;!-- FactoryBean实例化 Bean --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user-by-factory-bean"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bean.factory.UserFactoryBean"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userFactory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bean.factory.DefaultUserFactory"</span>/&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultUserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserFactory</span> </span>&#123;&#125;</code></pre><h4 id="通过构造器"><a href="#通过构造器" class="headerlink" title="通过构造器"></a>通过构造器</h4><p>  包括带参构造器和不带参构造器。（配置元信息：XML、Java 注解和Java API ）</p><h4 id="通过静态工厂方法"><a href="#通过静态工厂方法" class="headerlink" title="通过静态工厂方法"></a>通过静态工厂方法</h4><p>  采用类的静态方法。（配置元信息：XML 和Java API ）<br>  构造Domain 的User类，并加入静态方法：</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String name;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> User <span class="hljs-title">createUser</span><span class="hljs-params">()</span> </span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setId(<span class="hljs-number">1L</span>);        user.setName(<span class="hljs-string">"John"</span>);        <span class="hljs-keyword">return</span> user;    &#125;&#125;</code></pre><p>使用该静态方法：</p><pre><code class="hljs java"><span class="hljs-comment">// 配置 XML 配置文件</span><span class="hljs-comment">// 启动 Spring 应用上下文</span>BeanFactory beanFactory = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:/META-INF/bean-instantiation-context.xml"</span>);User user = beanFactory.getBean(<span class="hljs-string">"user-by-static-method"</span>, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;System.out.println(user);</code></pre><p>输出为：</p><pre><code class="hljs shell">User&#123;id=1, name='John'&#125;</code></pre><h4 id="通过Bean-工厂方法（很少采用）"><a href="#通过Bean-工厂方法（很少采用）" class="headerlink" title="通过Bean 工厂方法（很少采用）"></a>通过Bean 工厂方法（很少采用）</h4><p>   实例的工厂方法。抽象工厂模式。（配置元信息：XML和Java API ）</p><p>构造抽象工厂类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">default</span> User <span class="hljs-title">createUser</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> User.createUser(); &#125;&#125;</code></pre><p>然后构造工厂实现类，因为Interface中已经定义默认方法，所以<code>DefaultUserFactory</code>无需实现该方法：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultUserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserFactory</span> </span>&#123;&#125;</code></pre><p>使用：</p><pre><code class="hljs java">BeanFactory beanFactory = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:/META-INF/bean-instantiation-context.xml"</span>);User user = beanFactory.getBean(<span class="hljs-string">"user-by-static-method"</span>, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;User userByInstanceMethod = beanFactory.getBean(<span class="hljs-string">"user-by-instance-method"</span>, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;System.out.println(user);System.out.println(userByInstanceMethod);System.out.println(user == userByInstanceMethod);</code></pre><p>输出为：</p><pre><code class="hljs shell">User&#123;id=1, name='John'&#125;User&#123;id=1, name='John'&#125;flase</code></pre><h4 id="通过FactoryBean"><a href="#通过FactoryBean" class="headerlink" title="通过FactoryBean"></a>通过<code>FactoryBean</code></h4><p>（配置元信息：XML、Java 注解和Java API ）</p><p>Bean的FactoryBean实现：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">return</span> User.createUser();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;        <span class="hljs-keyword">return</span> User<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;    &#125;&#125;</code></pre><p>代码：</p><pre><code class="hljs java"><span class="hljs-comment">// 配置 XML 配置文件</span><span class="hljs-comment">// 启动 Spring 应用上下文</span>BeanFactory beanFactory = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:/META-INF/bean-instantiation-context.xml"</span>);User user = beanFactory.getBean(<span class="hljs-string">"user-by-static-method"</span>, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;User userByInstanceMethod = beanFactory.getBean(<span class="hljs-string">"user-by-instance-method"</span>, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;User userByFactoryBean = beanFactory.getBean(<span class="hljs-string">"user-by-factory-bean"</span>, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;System.out.println(user);System.out.println(userByInstanceMethod);System.out.println(userByFactoryBean);System.out.println(user == userByInstanceMethod);System.out.println(user == userByFactoryBean);System.out.println(userByInstanceMethod == userByFactoryBean);</code></pre><p>输出为：</p><pre><code class="hljs shell">User&#123;id=1, name='John'&#125;User&#123;id=1, name='John'&#125;User&#123;id=1, name='John'&#125;flaseflaseflase</code></pre><h3 id="特殊方式"><a href="#特殊方式" class="headerlink" title="特殊方式"></a>特殊方式</h3><p>配置<code>META-INF/special-bean-instantiation-context.xml</code>：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userFactoryServiceLoader"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.beans.factory.serviceloader.ServiceLoaderFactoryBean"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"serviceType"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"bean.factory.UserFactory"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><h4 id="通过ServiceLoaderFactoryBean"><a href="#通过ServiceLoaderFactoryBean" class="headerlink" title="通过ServiceLoaderFactoryBean"></a>通过<code>ServiceLoaderFactoryBean</code></h4><p>（配置元信息：XML、Java 注解和Java API ）</p><p>创建文件<code>META-INF/services/bean.factory.UserFactory</code>，其中，<code>bean.factory.UserFactory</code>是实现类的全名字，该文件中包括了实现类的全名，如有多个，分多行写入。</p><pre><code class="hljs java">BeanFactory beanfactory = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:/META-INF/special-bean-instantiation-context.xml"</span>);ServiceLoader&lt;UserFactory&gt; serviceLoader = beanfactory.getBean(<span class="hljs-string">"userFactoryServiceLoader"</span>, ServiceLoader<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;displayServiceLoader(serviceLoader);<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">displayServiceLoader</span><span class="hljs-params">(ServiceLoader&lt;UserFactory&gt; serviceLoader)</span> </span>&#123;    Iterator&lt;UserFactory&gt; iterator = serviceLoader.iterator();    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;        UserFactory userFactory = iterator.next();        System.out.println(userFactory.createUser());    &#125;&#125;</code></pre><p>输出为：</p><pre><code class="hljs shell">User&#123;id=1, name='John'&#125;</code></pre><p>重构后代码为：</p><pre><code class="hljs java"><span class="hljs-comment">// 配置 XML 配置文件</span><span class="hljs-comment">// 启动 Spring 应用上下文</span>BeanFactory beanfactory = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:/META-INF/special-bean-instantiation-context.xml"</span>);ServiceLoader&lt;UserFactory&gt; serviceLoader = beanfactory.getBean(<span class="hljs-string">"userFactoryServiceLoader"</span>, ServiceLoader<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;demoServiceLoader();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demoServiceLoader</span><span class="hljs-params">()</span> </span>&#123;    ServiceLoader&lt;UserFactory&gt; serviceLoader = load(UserFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Thread</span>.<span class="hljs-title">currentThread</span>().<span class="hljs-title">getContextClassLoader</span>())</span>;    displayServiceLoader(serviceLoader);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">displayServiceLoader</span><span class="hljs-params">(ServiceLoader&lt;UserFactory&gt; serviceLoader)</span> </span>&#123;    Iterator&lt;UserFactory&gt; iterator = serviceLoader.iterator();    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;        UserFactory userFactory = iterator.next();        System.out.println(userFactory.createUser());    &#125;&#125;</code></pre><p>输出为：</p><pre><code class="hljs shell">User&#123;id=1, name='John'&#125;</code></pre><p>如有多个，则会依次输出所有的bean。</p><h4 id="通过AutowireCapableBeanFactory-createBean-java-lang-Class-int-boolean"><a href="#通过AutowireCapableBeanFactory-createBean-java-lang-Class-int-boolean" class="headerlink" title="通过AutowireCapableBeanFactory#createBean(java.lang.Class, int, boolean)"></a>通过<code>AutowireCapableBeanFactory#createBean(java.lang.Class, int, boolean)</code></h4><p>通过 ApplicationContext 获取 AutowireCapableBeanFactory:</p><pre><code class="hljs java">ApplicationContext applicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:/META-INF/special-bean-instantiation-context.xml"</span>);<span class="hljs-comment">// 通过 ApplicationContext 获取 AutowireCapableBeanFactory</span>AutowireCapableBeanFactory beanFactory = applicationContext.getAutowireCapableBeanFactory();ServiceLoader&lt;UserFactory&gt; serviceLoader = beanFactory.getBean(<span class="hljs-string">"userFactoryServiceLoader"</span>, ServiceLoader<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;displayServiceLoader(serviceLoader);<span class="hljs-comment">// 创建 UserFactory 对象，通过 AutowireCapableBeanFactory</span>UserFactory userFactory = beanFactory.createBean(DefaultUserFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;System.out.println(userFactory.createUser());</code></pre><p>输出为：</p><pre><code class="hljs shell">User&#123;id=1, name='John'&#125; // displayServiceLoader 输出User&#123;id=1, name='John'&#125; // System.out.println(userFactory.createUser()) 输出</code></pre><h4 id="通过BeanDefinitionRegistry-registerBeanDefinition-String-BeanDefinition"><a href="#通过BeanDefinitionRegistry-registerBeanDefinition-String-BeanDefinition" class="headerlink" title="通过BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)"></a>通过<code>BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)</code></h4><h2 id="初始化Spring-Bean-Initialization"><a href="#初始化Spring-Bean-Initialization" class="headerlink" title="初始化Spring Bean (Initialization)"></a>初始化Spring Bean (Initialization)</h2><h3 id="PostConstruct标注方法"><a href="#PostConstruct标注方法" class="headerlink" title="@PostConstruct标注方法"></a>@PostConstruct标注方法</h3><p>在具体类中加入<code>@PostConstruct</code>标注</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultUserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserFactory</span> </span>&#123;    <span class="hljs-comment">// 1. 基于 @PostConstruct 注解</span>    <span class="hljs-meta">@PostConstruct</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"@PostConstruct : UserFactory 初始化中..."</span>);    &#125;    &#125;</code></pre><p>运行：</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">// Configuration Class</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanInitializationDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 创建 BeanFactory 容器</span>        AnnotationConfigApplicationContext applicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();        <span class="hljs-comment">// 注册 Configuration Class（配置类）</span>        applicationContext.register(BeanInitializationDemo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">// 启动 Spring 应用上下文</span>        applicationContext.refresh();        <span class="hljs-comment">// 依赖查找 UserFactory</span>        UserFactory userFactory = applicationContext.getBean(UserFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">// 关闭 Spring 应用上下文</span>        applicationContext.close();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserFactory <span class="hljs-title">userFactory</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultUserFactory();    &#125;&#125;</code></pre><p>输出为：</p><pre><code class="hljs shell">@PostConstruct : UserFactory 初始化中...</code></pre><h3 id="实现InitializingBean接口的-afterPropertiesSet-方法"><a href="#实现InitializingBean接口的-afterPropertiesSet-方法" class="headerlink" title="实现InitializingBean接口的 afterPropertiesSet()方法"></a>实现<code>InitializingBean</code>接口的 <code>afterPropertiesSet()</code>方法</h3><p>在具体类中：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultUserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserFactory</span>, <span class="hljs-title">InitializingBean</span> </span>&#123;    <span class="hljs-comment">// 1. 基于 @PostConstruct 注解</span>    <span class="hljs-meta">@PostConstruct</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"@PostConstruct : UserFactory 初始化中..."</span>);    &#125;       <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"InitializingBean#afterPropertiesSet() : UserFactory 初始化中..."</span>);    &#125;&#125;</code></pre><p>输出为：</p><pre><code class="hljs she">@PostConstruct : UserFactory 初始化中...InitializingBean#afterPropertiesSet() : UserFactory 初始化中...</code></pre><h3 id="自定义初始化方法"><a href="#自定义初始化方法" class="headerlink" title="自定义初始化方法"></a>自定义初始化方法</h3><h4 id="使用Java注解-Bean-initMethod-quot-quot"><a href="#使用Java注解-Bean-initMethod-quot-quot" class="headerlink" title="使用Java注解@Bean(initMethod=&quot; &quot;)"></a>使用Java注解<code>@Bean(initMethod=&quot; &quot;)</code></h4><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>(initMethod = <span class="hljs-string">"initUserFactory"</span>, destroyMethod = <span class="hljs-string">"doDestroy"</span>)<span class="hljs-meta">@Lazy</span>(value = <span class="hljs-keyword">false</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> UserFactory <span class="hljs-title">userFactory</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultUserFactory();&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultUserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserFactory</span>, <span class="hljs-title">InitializingBean</span> </span>&#123;    <span class="hljs-meta">@PostConstruct</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"@PostConstruct : UserFactory 初始化中..."</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initUserFactory</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"自定义初始化方法 initUserFactory() : UserFactory 初始化中..."</span>);    &#125;              <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"InitializingBean#afterPropertiesSet() : UserFactory 初始化中..."</span>);    &#125;&#125;</code></pre><p>输出为：</p><pre><code class="hljs shell">@PostConstruct : UserFactory 初始化中...<span class="hljs-meta">InitializingBean#</span><span class="bash">afterPropertiesSet() : UserFactory 初始化中...</span>自定义初始化方法 initUserFactory() : UserFactory 初始化中...</code></pre><h4 id="使用Java-API-AbstractBeanDefinition-setInitMethodName-String"><a href="#使用Java-API-AbstractBeanDefinition-setInitMethodName-String" class="headerlink" title="使用Java API AbstractBeanDefinition#setInitMethodName(String)"></a>使用Java API <code>AbstractBeanDefinition#setInitMethodName(String)</code></h4>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spirng IOC Container</title>
    <link href="/2020/04/19/Spirng-IOC-Container/"/>
    <url>/2020/04/19/Spirng-IOC-Container/</url>
    
    <content type="html"><![CDATA[<!-- # Spring IOC Container 容器 --><h2 id="Spring-IoC-依赖查找"><a href="#Spring-IoC-依赖查找" class="headerlink" title="Spring IoC 依赖查找"></a>Spring IoC 依赖查找</h2><h3 id="初始准备工作"><a href="#初始准备工作" class="headerlink" title="初始准备工作"></a>初始准备工作</h3><h4 id="创建用户类"><a href="#创建用户类" class="headerlink" title="创建用户类"></a>创建用户类</h4><p>创建用户类作为示例</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-keyword">private</span> String name;&#125;</code></pre><h4 id="创建xml配置文件"><a href="#创建xml配置文件" class="headerlink" title="创建xml配置文件"></a>创建xml配置文件</h4><p>在<code>src/main/resources/META-INF</code>目录下创建<code>dependency-lookup-context.xml</code>配置文件，并配置属性：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ioc.overview.domain.User"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"id"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"John"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><h4 id="代码配置xml配置文件，并启动Spring应用上下文"><a href="#代码配置xml配置文件，并启动Spring应用上下文" class="headerlink" title="代码配置xml配置文件，并启动Spring应用上下文"></a>代码配置xml配置文件，并启动Spring应用上下文</h4><pre><code class="hljs java"><span class="hljs-comment">// 配置 XML 配置文件</span><span class="hljs-comment">// 启动 Spring 应用上下文</span>BeanFactory beanFactory =    <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:/META-INF/dependency-lookup-context.xml"</span>);</code></pre><h3 id="根据Bean-名称查找"><a href="#根据Bean-名称查找" class="headerlink" title="根据Bean 名称查找"></a>根据Bean 名称查找</h3><h4 id="实时查找"><a href="#实时查找" class="headerlink" title="实时查找"></a>实时查找</h4><p>启动Spring应用上下文后，直接通过Bean名称查找就可以查找到相应的Bean:</p><pre><code class="hljs ava">User user &#x3D; (User) beanFactory.getBean(&quot;user&quot;);</code></pre><p>这种方式是<strong>实时查找</strong>，整理代码可得：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// 配置 XML 配置文件</span>    <span class="hljs-comment">// 启动 Spring 应用上下文</span>    BeanFactory beanFactory =        <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:/META-INF/dependency-lookup-context.xml"</span>);    lookupInRealTime(beanFactory);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lookupInRealTime</span><span class="hljs-params">(BeanFactory beanFactory)</span> </span>&#123;    User user = (User) beanFactory.getBean(<span class="hljs-string">"user"</span>);    System.out.println(<span class="hljs-string">"实时查找："</span> + user);&#125;</code></pre><p>运行得到的结果为：</p><pre><code class="hljs shell">实时查找：User&#123;id=1, name='John'&#125;</code></pre><h4 id="延迟查找"><a href="#延迟查找" class="headerlink" title="延迟查找"></a>延迟查找</h4><p><code>org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean</code>是<code>org.springframework.beans.factory.ObjectFactory</code> 的一个具体实现。</p><p>在xml配置文件中，增加其配置，并在其属性中增加其所关联的bean（在这里，我们直接关联上面的 bean id）作为<code>targetBeanName</code>：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"objectFactory"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"targetBeanName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"user"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>通过<code>objectFactory</code>这个bean，就可以获得<code>user</code>这个bean，这种方式是<strong>延迟查找</strong>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lookupInLazy</span><span class="hljs-params">(BeanFactory beanFactory)</span> </span>&#123;    <span class="hljs-comment">// 必须进行通过强转来适配</span>    ObjectFactory&lt;User&gt; objectFactory = (ObjectFactory&lt;User&gt;) beanFactory.getBean(<span class="hljs-string">"objectFactory"</span>);    User user = objectFactory.getObject();    System.out.println(<span class="hljs-string">"延迟查找："</span> + user);&#125;</code></pre><p>运行得到的结果为：</p><pre><code class="hljs shell">延迟查找：User&#123;id=1, name='John'&#125;</code></pre><h3 id="根据Bean-类型查找"><a href="#根据Bean-类型查找" class="headerlink" title="根据Bean 类型查找"></a>根据Bean 类型查找</h3><p>根据类型查找的原理与根据名称查找类似。直接使用Class Type进行查找即可。</p><h4 id="单个Bean-对象"><a href="#单个Bean-对象" class="headerlink" title="单个Bean 对象"></a>单个Bean 对象</h4><pre><code class="hljs java"><span class="hljs-comment">// 按照类型查找</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lookupByType</span><span class="hljs-params">(BeanFactory beanFactory)</span> </span>&#123;    User user = beanFactory.getBean(User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    System.out.println(<span class="hljs-string">"实时查找："</span> + user);&#125;</code></pre><h4 id="集合Bean-对象"><a href="#集合Bean-对象" class="headerlink" title="集合Bean 对象"></a>集合Bean 对象</h4><p>需要使用<code>org.springframework.beans.factory.ListableBeanFactory</code>进行类型转化。</p><pre><code class="hljs java"><span class="hljs-comment">// 按照类型查找结合对象</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lookupCollectionByType</span><span class="hljs-params">(BeanFactory beanFactory)</span> </span>&#123;    <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> ListableBeanFactory) &#123;        ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;        Map&lt;String, User&gt; users = listableBeanFactory.getBeansOfType(User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        System.out.println(<span class="hljs-string">"查找到的所有的 User 集合对象："</span> + users);    &#125;&#125;</code></pre><p>运行结果为：</p><pre><code class="hljs shell">查找到的所有的 User 集合对象：&#123;user=User&#123;id=1, name='John'&#125;&#125;</code></pre><h3 id="根据Bean-名称-类型查找"><a href="#根据Bean-名称-类型查找" class="headerlink" title="根据Bean 名称+ 类型查找"></a>根据Bean 名称+ 类型查找</h3><h3 id="根据Java-注解查找"><a href="#根据Java-注解查找" class="headerlink" title="根据Java 注解查找"></a>根据Java 注解查找</h3><p>首先准备一个SuperUser，增加一个字段，同时为了区分<code>SuperUser</code>和<code>User</code>， 需要定义一个<code>@Super</code>注解来进行区分。</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(ElementType.TYPE)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Super &#123;&#125;</code></pre><p>使用这个注解，进行区分，<code>User</code>没有<code>@Super</code>注解，而<code>SuperUser</code>有<code>@Super</code>注解：</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span> <span class="hljs-meta">@Super</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperUser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> String address;&#125;</code></pre><p>在xml文件中，配置<code>SuperUser</code>的bean：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 普通 beanDefinition GenericBeanDefinition --&gt;</span><span class="hljs-comment">&lt;!-- 合并后 GenericBeanDefinition 变成 RootBeanDefinition，并且覆盖 parent 相关配置--&gt;</span><span class="hljs-comment">&lt;!-- primary = true , 增加了一个 address 属性 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"superUser"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ioc.overview.domain.SuperUser"</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">primary</span>=<span class="hljs-string">"true"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"address"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Toronto"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>如果不使用<code>primary=&quot;true&quot;</code>，那么Spring会抛出错误，因为会查找到两个bean：<code>User</code>和<code>SuperUser</code>。</p><h4 id="单个Bean-对象-1"><a href="#单个Bean-对象-1" class="headerlink" title="单个Bean 对象"></a>单个Bean 对象</h4><p>查找使用了<code>@Super</code>这个注解的对象：</p><pre><code class="hljs JAVA"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lookupByAnnotationType</span><span class="hljs-params">(BeanFactory beanFactory)</span> </span>&#123;    <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> ListableBeanFactory) &#123;        ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;        Map&lt;String, User&gt; users = (Map) listableBeanFactory.getBeansWithAnnotation(Super<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        System.out.println(<span class="hljs-string">"查找标注 @Super 所有的 User 集合对象："</span> + users);    &#125;&#125;</code></pre><h4 id="集合Bean-对象-1"><a href="#集合Bean-对象-1" class="headerlink" title="集合Bean 对象"></a>集合Bean 对象</h4><p>与根据Bean名称查找类似。</p><h2 id="Spring-IoC-依赖注入"><a href="#Spring-IoC-依赖注入" class="headerlink" title="Spring IoC 依赖注入"></a>Spring IoC 依赖注入</h2><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><h4 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepository</span> </span>&#123;    <span class="hljs-keyword">private</span> Collection&lt;User&gt; users; <span class="hljs-comment">// 自定义 Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;User&gt; <span class="hljs-title">getUsers</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> users;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsers</span><span class="hljs-params">(Collection&lt;User&gt; users)</span> </span>&#123;        <span class="hljs-keyword">this</span>.users = users;    &#125;&#125;</code></pre><h4 id="创建xml配置文件-1"><a href="#创建xml配置文件-1" class="headerlink" title="创建xml配置文件"></a>创建xml配置文件</h4><p>创建<code>src/main/resources/META-INF/dependency-injection-context.xml</code>，可以通过导入复用之前的xml配置文件，并通过手动配置bean list（注意，需要引入<code>http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd</code>才可以使用<code>util:list</code>。</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 通过导入复用 dependency-lookup-context.xml --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"dependency-lookup-context.xml"</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userRepository"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ioc.overview.repository.UserRepository"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 手动配置 --&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"users"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">util:list</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"superUser"</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">ref</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">"user"</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">util:list</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>使用上述方法，输出为 SuperUser 和 User。</p><h5 id="使用autowire进行自动配置，推荐"><a href="#使用autowire进行自动配置，推荐" class="headerlink" title="使用autowire进行自动配置，推荐"></a>使用<code>autowire</code>进行自动配置，<strong>推荐</strong></h5><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userRepository"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ioc.overview.repository.UserRepository"</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">"byType"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>使用<code>autowire</code>进行自动配置，其Bean出现的顺序，是<strong>按照bean的定义顺序来进行执行</strong>的。使用上述方法，输出必定为 User 和 SuperUser ， 因为我们先定义了User， 然后定义了SuperUser。</p><h4 id="代码配置xml配置文件，并启动Spring应用上下文-1"><a href="#代码配置xml配置文件，并启动Spring应用上下文-1" class="headerlink" title="代码配置xml配置文件，并启动Spring应用上下文"></a>代码配置xml配置文件，并启动Spring应用上下文</h4><pre><code class="hljs java"><span class="hljs-comment">// 配置 XML 配置文件</span><span class="hljs-comment">// 启动 Spring 应用上下文</span>BeanFactory beanFactory =    <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:/META-INF/dependency-injection-context.xml"</span>);</code></pre><h3 id="根据Bean-名称-类型-注入"><a href="#根据Bean-名称-类型-注入" class="headerlink" title="根据Bean 名称/类型 注入"></a>根据Bean 名称/类型 注入</h3><p>示例代码：</p><pre><code class="hljs java">UserRepository userRepository = applicationContext.getBean(<span class="hljs-string">"userRepository"</span>, UserRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;System.out.println(userRepository.getUsers());</code></pre><h3 id="注入容器內建Bean-对象"><a href="#注入容器內建Bean-对象" class="headerlink" title="注入容器內建Bean 对象"></a>注入容器內建Bean 对象</h3><h3 id="注入非Bean-对象"><a href="#注入非Bean-对象" class="headerlink" title="注入非Bean 对象"></a>注入非Bean 对象</h3><h4 id="增加內建非-Bean-对象"><a href="#增加內建非-Bean-对象" class="headerlink" title="增加內建非 Bean 对象"></a>增加內建非 Bean 对象</h4><p>在Repository中增加<strong>內建非 Bean 对象</strong>：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> BeanFactory beanFactory; <span class="hljs-comment">// 內建非 Bean 对象（依赖）</span><span class="hljs-function"><span class="hljs-keyword">public</span> BeanFactory <span class="hljs-title">getBeanFactory</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">return</span> beanFactory;   &#125;</code></pre><p>使用Repository中的get方法，<code>userRepository.getBeanFactory()</code> 获得的结果，并不是Spring 应用上下文取得的<code>beanFactory</code>。</p><pre><code class="hljs java">BeanFactory beanFactory =    <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:/META-INF/dependency-injection-context.xml"</span>);  UserRepository userRepository = applicationContext.getBean(<span class="hljs-string">"userRepository"</span>, UserRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;System.out.println(userFactory.getBeanFactory() == beanFactory); <span class="hljs-comment">// 输出结果为false</span></code></pre><p>上述代码的输出结果为<code>false</code>。</p><p>实际上，<code>userFactory.getBeanFactory()</code>的输出结果为：</p><pre><code class="hljs shell">org.springframework.beans.factory.support.DefaultListableBeanFactory@42e99e4a: defining beans [user,superUser,objectFactory,userRepository]; root of factory hierarchy</code></pre><p>获得了4个bean： <code>user,superUser,objectFactory,userRepository</code>。</p><h4 id="验证內建对象是非-Bean-对象"><a href="#验证內建对象是非-Bean-对象" class="headerlink" title="验证內建对象是非 Bean 对象"></a>验证內建对象是非 Bean 对象</h4><p>但是，我们在<code>UserRepository</code>中增加的<code>beanFactory</code>并不是一个Bean对象，而是一个内建对象。</p><p>如果通过</p><pre><code class="hljs java">System.out.println(beanFactory.getBean(BeanFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;</code></pre><p>查看，则会抛出错误：</p><pre><code class="hljs shell">No qualifying bean of type 'org.springframework.beans.factory.BeanFactory' available</code></pre><h3 id="注入类型"><a href="#注入类型" class="headerlink" title="注入类型"></a>注入类型</h3><h4 id="实时注入"><a href="#实时注入" class="headerlink" title="实时注入"></a>实时注入</h4><p>以上的代码均为实时注入。</p><h4 id="延迟注入"><a href="#延迟注入" class="headerlink" title="延迟注入"></a>延迟注入</h4><p>在Repository中增加Field:</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> ObjectFactory&lt;User&gt; objectFactory;<span class="hljs-function"><span class="hljs-keyword">public</span> ObjectFactory&lt;User&gt; <span class="hljs-title">getObjectFactory</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> objectFactory;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setObjectFactory</span><span class="hljs-params">(ObjectFactory&lt;User&gt; objectFactory)</span> </span>&#123;    <span class="hljs-keyword">this</span>.objectFactory = objectFactory;&#125;</code></pre><p>通过下述代码可以得到<code>SuperUser</code>对象。</p><pre><code class="hljs java">ObjectFactory userFactory = userRepository.getObjectFactory();System.out.println(userFactory.getObjext());</code></pre><p>输出结果为：</p><pre><code class="hljs shell">SuperUser&#123;address='Toronro'&#125; User&#123;id=1, name='John'&#125;</code></pre><p>如果将<code>UserRepository</code>中的<code>objectFactory</code>类型更改为<code>ApplicationContext</code>：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> ObjectFactory&lt;ApplicationContext&gt; objectFactory;</code></pre><p>则上述代码输出结果为：</p><pre><code class="hljs shell">org.springframework.context.support.ClassPathXmlApplicationContext@245f6ad</code></pre><p>而<code>System.out.println(userFactory.getObject() == beanFactory)</code>的输出结果为<code>true</code>。完整代码如下：</p><pre><code class="hljs java">BeanFactory beanFactory =    <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"classpath:/META-INF/dependency-injection-context.xml"</span>);  UserRepository userRepository = applicationContext.getBean(<span class="hljs-string">"userRepository"</span>, UserRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;ObjectFactory userFactory = userRepository.getObjectFactory();System.out.println(userFactory.getObject() == beanFactory); <span class="hljs-comment">// 结果为true</span></code></pre><h2 id="Spring-IoC-依赖来源"><a href="#Spring-IoC-依赖来源" class="headerlink" title="Spring IoC 依赖来源"></a>Spring IoC 依赖来源</h2><p>来源于下述三个地方：</p><ul><li><p>自定义Bean （业务上的Bean）</p><p>在上面的代码中，<code>UserRepository</code>是一个自定义bean</p><pre><code class="hljs java"><span class="hljs-comment">// 依赖来源一：自定义 Bean</span>UserRepository userRepository = applicationContext.getBean(<span class="hljs-string">"userRepository"</span>, UserRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre></li></ul><ul><li><p>容器內建Bean 对象</p><pre><code class="hljs java"><span class="hljs-comment">// 依赖来源三：容器內建 Bean</span>Environment environment = applicationContext.getBean(Environment<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;System.out.println(<span class="hljs-string">"获取 Environment 类型的 Bean："</span> + environment);</code></pre></li></ul><ul><li><p>容器內建依赖（非Spring Bean）</p><p>而<code>BeanFactory</code>则是容器内建依赖</p><pre><code class="hljs java"><span class="hljs-comment">// 依赖来源二：依赖注入（內建依赖）</span>System.out.println(userRepository.getBeanFactory());</code></pre></li></ul><h2 id="Spring-IoC-配置元信息"><a href="#Spring-IoC-配置元信息" class="headerlink" title="Spring IoC 配置元信息"></a>Spring IoC 配置元信息</h2><h3 id="Bean-定义配置"><a href="#Bean-定义配置" class="headerlink" title="Bean 定义配置"></a>Bean 定义配置</h3><h4 id="基于XML-文件"><a href="#基于XML-文件" class="headerlink" title="基于XML 文件"></a>基于XML 文件</h4><h4 id="基于Properties-文件"><a href="#基于Properties-文件" class="headerlink" title="基于Properties 文件"></a>基于Properties 文件</h4><h4 id="基于Java-注解"><a href="#基于Java-注解" class="headerlink" title="基于Java 注解"></a>基于Java 注解</h4><h4 id="基于Java-API（专题讨论）"><a href="#基于Java-API（专题讨论）" class="headerlink" title="基于Java API（专题讨论）"></a>基于Java API（专题讨论）</h4><h3 id="IoC-容器配置"><a href="#IoC-容器配置" class="headerlink" title="IoC 容器配置"></a>IoC 容器配置</h3><h4 id="基于XML-文件-1"><a href="#基于XML-文件-1" class="headerlink" title="基于XML 文件"></a>基于XML 文件</h4><h4 id="基于Java-注解-1"><a href="#基于Java-注解-1" class="headerlink" title="基于Java 注解"></a>基于Java 注解</h4><h4 id="基于Java-API-（专题讨论）"><a href="#基于Java-API-（专题讨论）" class="headerlink" title="基于Java API （专题讨论）"></a>基于Java API （专题讨论）</h4><h3 id="I外部化属性配置"><a href="#I外部化属性配置" class="headerlink" title="I外部化属性配置"></a>I外部化属性配置</h3><h4 id="基于Java-注解-2"><a href="#基于Java-注解-2" class="headerlink" title="基于Java 注解"></a>基于Java 注解</h4><h2 id="Spring-IoC-容器"><a href="#Spring-IoC-容器" class="headerlink" title="Spring IoC 容器"></a>Spring IoC 容器</h2><p>The <code>org.springframework.beans</code> and <code>org.springframework.context</code> packages are the basis for Spring Framework’s IoC container. The <a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="noopener"><code>BeanFactory</code></a> interface provides an advanced configuration mechanism capable of managing any type of object. <a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html" target="_blank" rel="noopener"><code>ApplicationContext</code></a> is a sub-interface of <code>BeanFactory</code>. It adds:</p><ul><li>Easier integration with Spring’s AOP features</li><li>Message resource handling (for use in internationalization)</li><li>Event publication</li><li>Application-layer specific contexts such as the <code>WebApplicationContext</code> for use in web applications.</li></ul><p>In short, the <code>BeanFactory</code> provides the configuration framework and basic functionality, and the <code>ApplicationContext</code> adds more enterprise-specific functionality. The <code>ApplicationContext</code> is a complete superset of the <code>BeanFactory</code> and is used exclusively in this chapter in descriptions of Spring’s IoC container.</p><h2 id="Spring-应用上下文"><a href="#Spring-应用上下文" class="headerlink" title="Spring 应用上下文"></a>Spring 应用上下文</h2><p>ApplicationContext 除了IoC 容器角色，还有提供：<br>• 面向切面（AOP）<br>• 配置元信息（Configuration Metadata）<br>• 资源管理（Resources）<br>• 事件（Events）<br>• 国际化（i18n）<br>• 注解（Annotations）<br>• Environment 抽象（Environment Abstraction）</p><h2 id="使用Spring-IoC-容器"><a href="#使用Spring-IoC-容器" class="headerlink" title="使用Spring IoC 容器"></a>使用Spring IoC 容器</h2><h3 id="BeanFactory-是Spring-底层IoC-容器"><a href="#BeanFactory-是Spring-底层IoC-容器" class="headerlink" title="BeanFactory 是Spring 底层IoC 容器"></a>BeanFactory 是Spring 底层IoC 容器</h3><p>采用 BeanFactory，提供了基本的IoC功能。</p><pre><code class="hljs java"><span class="hljs-comment">// 创建 BeanFactory 容器</span>DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();XmlBeanDefinitionReader reader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(beanFactory);<span class="hljs-comment">// XML 配置文件 ClassPath 路径</span>String location = <span class="hljs-string">"classpath:/META-INF/dependency-lookup-context.xml"</span>;<span class="hljs-comment">// 加载配置</span><span class="hljs-keyword">int</span> beanDefinitionsCount = reader.loadBeanDefinitions(location);System.out.println(<span class="hljs-string">"Bean 定义加载的数量："</span> + beanDefinitionsCount); <span class="hljs-comment">// 输出为 3</span><span class="hljs-comment">// 依赖查找集合对象</span>lookupCollectionByType(beanFactory);</code></pre><h3 id="ApplicationContext-是具备应用特性的BeanFactory-超集"><a href="#ApplicationContext-是具备应用特性的BeanFactory-超集" class="headerlink" title="ApplicationContext 是具备应用特性的BeanFactory 超集"></a>ApplicationContext 是具备应用特性的BeanFactory 超集</h3><p>首先，通过 Java 注解的方式，定义了一个 Bean。</p><pre><code class="hljs java"><span class="hljs-comment">// 通过 Java 注解的方式，定义了一个 Bean</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;    User user = <span class="hljs-keyword">new</span> User();    user.setId(<span class="hljs-number">1L</span>);    user.setName(<span class="hljs-string">"John"</span>);    <span class="hljs-keyword">return</span> user;&#125;</code></pre><p>然后，采用ApplicationContext :</p><pre><code class="hljs java"><span class="hljs-comment">// 创建 ApplicationContext  容器</span>AnnotationConfigApplicationContext applicationContext = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<span class="hljs-comment">// 将当前类 AnnotationApplicationContextAsIoCContainerDemo 作为配置类（Configuration Class）</span>applicationContext.register(AnnotationApplicationContextAsIoCContainerDemo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-comment">// 启动应用上下文</span>applicationContext.refresh();<span class="hljs-comment">// 依赖查找集合对象</span>lookupCollectionByType(applicationContext);<span class="hljs-comment">// 关闭应用上下文</span>applicationContext.close();</code></pre><h2 id="Spring-IoC-容器生命周期"><a href="#Spring-IoC-容器生命周期" class="headerlink" title="Spring IoC 容器生命周期"></a>Spring IoC 容器生命周期</h2><p><strong>BeanFactory 是IoC 底层容器</strong><br><strong>FactoryBean 是创建Bean 的一种方式，帮助实现复杂的初始化逻辑</strong></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular 8: Content Projection, Router, Pipe and Dependency Injection</title>
    <link href="/2019/08/24/Angular-8-Content-Projection-Router-Pipe-and-Dependency-Injection%20copy/"/>
    <url>/2019/08/24/Angular-8-Content-Projection-Router-Pipe-and-Dependency-Injection%20copy/</url>
    
    <content type="html"><![CDATA[<!-- # Angular 8: Content Projection, Router, Pipe and Dependency Injection --><p>Angular 8 Demo Project Log and Experience Part 4.</p><h2 id="Issue-about-Component-nesting"><a href="#Issue-about-Component-nesting" class="headerlink" title="Issue about Component nesting"></a>Issue about Component nesting</h2><p>Component nesting is inevitable. Think about the structure:</p><ul><li><p>AppComponent</p><ul><li>ChildComponent<ul><li>GrandComponent<ul><li>GrandGrandComponent</li></ul></li></ul></li></ul><p>We can use <code>@Input()</code> and <code>@Output</code> to realize the data transfer between nesting components or between components and outside world. </p><p>However, if we need to transfer between <code>AppComponent</code> and <code>GrandGrandComponent</code>, we need to transfer the data or event in two middle components too.</p><p>This over nesting can lead to complexity and redundancy in our codes.</p><p>To avoid the redundant data and events brought by component nesting, we can use </p><ul><li>content projection </li><li>router </li><li>directive </li><li>service</li></ul></li></ul><h2 id="Content-Projection"><a href="#Content-Projection" class="headerlink" title="Content Projection"></a>Content Projection</h2><p>Using <code>ng-content</code>to realize content projection.</p><ul><li>what: dynamic content</li><li>syntax: <code>&lt;ng-content select=&quot;style classes / HTML tags / directives&quot;&gt;&lt;/ng-content&gt;</code></li><li>possible scenarios: <ul><li>display dynamic contents </li><li>as a component container</li></ul></li></ul><p>Previously we just call the ChildComponent in AppComponent, such as </p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-scrollable-tab</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-scrollable-tab</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">app-image-slider</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-image-slider</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">app-horizontal-grid</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-horizontal-grid</span>&gt;</span></code></pre><p>In <code>horizontal-grid.component.html</code>, we display the content as follow:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItem</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of channels"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><span class="hljs-tag">    [<span class="hljs-attr">src</span>]=<span class="hljs-string">"item.icon"</span></span><span class="hljs-tag">    <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span></span><span class="hljs-tag">    [<span class="hljs-attr">appGridItemImage</span>]=<span class="hljs-string">"'2rem'"</span></span><span class="hljs-tag">     /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItemTitle</span>=<span class="hljs-string">"0.6rem"</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre><p>This is the normal way to use components.</p><h3 id="Refactor-to-ng-content"><a href="#Refactor-to-ng-content" class="headerlink" title="Refactor to ng-content"></a>Refactor to <code>ng-content</code></h3><p>We now change the <code>horizontal-grid.component.html</code> to the code:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ng-content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-content</span>&gt;</span></code></pre><p>then, change the <code>app.component.html</code> to modify the <code>app-horizontal-grid</code>, just simply move the code from <code>horizontal-grid.component.html</code>, we also need to change some css or imports.</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-horizontal-grid</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItem</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of channels"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><span class="hljs-tag">    [<span class="hljs-attr">src</span>]=<span class="hljs-string">"item.icon"</span></span><span class="hljs-tag">    <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span></span><span class="hljs-tag">    [<span class="hljs-attr">appGridItemImage</span>]=<span class="hljs-string">"'2rem'"</span></span><span class="hljs-tag">     /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItemTitle</span>=<span class="hljs-string">"0.6rem"</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-horizontal-grid</span>&gt;</span></code></pre><p>Thus, the <strong>Content Projection</strong> DONE.</p><p>We can also use some syntax:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ng-content</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"span"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-content</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ng-content</span> <span class="hljs-attr">select</span>=<span class="hljs-string">".special"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-content</span>&gt;</span> <span class="hljs-comment">&lt;!-- special is class name --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ng-content</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"[appGridItem]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-content</span>&gt;</span></code></pre><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>Routes includes:</p><ul><li>path</li><li>component</li><li>child router</li></ul><h3 id="Router-to-Home-Page"><a href="#Router-to-Home-Page" class="headerlink" title="Router to Home Page"></a>Router to Home Page</h3><p>The best practice is to create individual file to deal with the routes.</p><p>Create <code>app-routing.module.ts</code>:</p><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; NgModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> &#123; RouterModule, Routes &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;<span class="hljs-keyword">import</span> &#123; HomeContainerComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./home'</span>;<span class="hljs-keyword">const</span> routes: Routes = [  &#123; path: <span class="hljs-string">''</span>, component: HomeContainerComponent &#125;];<span class="hljs-meta">@NgModule</span>(&#123;  imports: [RouterModule.forRoot(routes)],  exports: [RouterModule]&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppRoutingModule &#123;&#125;</code></pre><p>Each Route maps a URL path to a component. There are <strong>no leading slashes(/)</strong> in the path. The router parses and builds the final URL for you, allowing you to use both relative and absolute paths when navigating between application views.</p><p>In <code>app.component.html</code> add  <code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code>. Then, import <code>AppRoutingModule</code> and <code>HomeModule</code> in <code>app.module.ts</code>.</p><h3 id="Child-Router-in-Home-Page"><a href="#Child-Router-in-Home-Page" class="headerlink" title="Child Router in Home Page"></a>Child Router in Home Page</h3><p>Create a child router in the home page as follows. In  <code>home-routing.module.ts</code>,</p><pre><code class="hljs ts"><span class="hljs-keyword">const</span> routes: Routes = [  &#123;    path: <span class="hljs-string">'home'</span>,    component: HomeContainerComponent,    children: [      &#123; path: <span class="hljs-string">''</span>, redirectTo: <span class="hljs-string">'hot'</span>, pathMatch: <span class="hljs-string">'full'</span> &#125;,      &#123; path: <span class="hljs-string">':tabLink'</span>, component: HomeDetailComponent &#125;    ]  &#125;];<span class="hljs-meta">@NgModule</span>(&#123;  imports: [RouterModule.forChild(routes)],  exports: [RouterModule]&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HomeRoutingModule &#123;&#125;</code></pre><p>Beware we use <strong><code>RouterModule.forChild(routes)</code></strong>.</p><p>When we visit the path like <code>localhost:4200/home/</code>, it will redirectTo <code>hot</code>.</p><p>The <code>:tabLink</code> in the second route is a token for a route parameter. In a URL such as <code>/home/toy</code>, “toy” is the value of the id parameter. The corresponding HomeDetailComponent will use that value to find and present the content whose id is toy.</p><p>In <code>home-container.component.html</code>, we also need to remove the following code:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-image-slider</span> [<span class="hljs-attr">sliders</span>]=<span class="hljs-string">"imagesSliders"</span> #<span class="hljs-attr">imageSlider</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-image-slider</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">app-horizontal-grid</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItem</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of channels"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">appGridItemImage</span>=<span class="hljs-string">"2rem"</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"item.icon"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItemTitle</span>=<span class="hljs-string">"1rem"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-horizontal-grid</span>&gt;</span></code></pre><p>and add <code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code>.</p><p>Because all contents will display in <code>HomeDetailComponent</code>, we need to move the removed code to <code>home-container.component.html</code>.</p><h3 id="Params-in-Router-URL"><a href="#Params-in-Router-URL" class="headerlink" title="Params in Router URL"></a>Params in Router URL</h3><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><pre><code class="hljs ts">&#123; path: <span class="hljs-string">':tabLink'</span>, component: HomeDetailComponent &#125;</code></pre><h3 id="Activation"><a href="#Activation" class="headerlink" title="Activation"></a>Activation</h3><p>Two way to activate the router. </p><p>The <code>tab.link</code> means the <code>link</code> property in interface <code>tab</code>;</p><h4 id="use-routerLink-in-template-html-file"><a href="#use-routerLink-in-template-html-file" class="headerlink" title="use routerLink in template(html file)."></a>use routerLink in template(html file).</h4><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- single param --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> [<span class="hljs-attr">routerLink</span>=<span class="hljs-string">"['/home', tab.link]"</span>]&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!-- the params can also carry multi  key-value pairs--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> [<span class="hljs-attr">routerLink</span>=<span class="hljs-string">"['/home', tab.link, &#123;name: 'val1'&#125;]"</span>]&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!-- the params can also carry query params --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> [<span class="hljs-attr">routerLink</span>=<span class="hljs-string">"['/home', tab.link, [queryParams]=&#123;name: 'val1'&#125;]"</span>]&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><h4 id="handle-the-event-in-ts-file"><a href="#handle-the-event-in-ts-file" class="headerlink" title="handle the event in ts file"></a>handle the event in ts file</h4><pre><code class="hljs ts"><span class="hljs-comment">// single param </span><span class="hljs-keyword">this</span>.router.navigate([<span class="hljs-string">'home'</span>, tab.link]);<span class="hljs-comment">// the params can also carry multi key-value pairs</span><span class="hljs-keyword">this</span>.router.navigate([<span class="hljs-string">'home'</span>, tab.link, &#123;name: <span class="hljs-string">'val1'</span>&#125;]);<span class="hljs-comment">// the params can also carry query params</span><span class="hljs-keyword">this</span>.router.navigate([<span class="hljs-string">'home'</span>, tab.link, &#123;queryParams: &#123;name: <span class="hljs-string">'val1'</span>&#125;&#125;]);</code></pre><h3 id="Corresponding-URL"><a href="#Corresponding-URL" class="headerlink" title="Corresponding URL"></a>Corresponding URL</h3><ul><li><code>http://localhost:4200/home/sports</code></li><li>with key-value pairs: <code>http://localhost:4200/home/sports;name=val1</code></li><li>with query params: <code>http://localhost:4200/home/sports?name=val1</code></li></ul><h3 id="Read-Params-in-URL"><a href="#Read-Params-in-URL" class="headerlink" title="Read Params in URL"></a>Read Params in URL</h3><pre><code class="hljs ts"><span class="hljs-comment">// with or without key-value pair params</span><span class="hljs-keyword">this</span>.route.paramsMap.subscribe(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;...&#125;);<span class="hljs-comment">// with query params</span><span class="hljs-keyword">this</span>.route.queryParamsMap.subscribe(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;...&#125;);</code></pre><h3 id="Router-code-sample"><a href="#Router-code-sample" class="headerlink" title="Router code sample"></a>Router code sample</h3><p>In <code>home-container.component.html</code>, we use <code>app-scrollable-tab</code> component.</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-scrollable-tab</span></span><span class="hljs-tag">  [<span class="hljs-attr">menus</span>]=<span class="hljs-string">"topMenus"</span></span><span class="hljs-tag">  (<span class="hljs-attr">tabSelected</span>)=<span class="hljs-string">"handleTabSelected($event)"</span></span><span class="hljs-tag">  [<span class="hljs-attr">backgroundColor</span>]=<span class="hljs-string">"'#fff'"</span></span><span class="hljs-tag">  <span class="hljs-attr">titleColor</span>=<span class="hljs-string">"#3f3f3f"</span></span><span class="hljs-tag">  <span class="hljs-attr">titleActiveColor</span>=<span class="hljs-string">"red"</span></span><span class="hljs-tag">  <span class="hljs-attr">indicatorColor</span>=<span class="hljs-string">"red"</span></span><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-scrollable-tab</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span></code></pre><p>In <code>HomeContainerComponent</code>, we have a function to navigate the router:</p><pre><code class="hljs ts"><span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> router: Router</span>) &#123;&#125;handleTabSelected(topMenu: TopMenu) &#123;  <span class="hljs-keyword">this</span>.router.navigate([<span class="hljs-string">'home'</span>, topMenu.link]);&#125;</code></pre><p>Modify the <code>HomeDetailComponent</code> html:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"selectedTabLink === 'hot'; else other"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">app-image-slider</span> [<span class="hljs-attr">sliders</span>]=<span class="hljs-string">"imagesSliders"</span> #<span class="hljs-attr">imageSlider</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-image-slider</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">app-horizontal-grid</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItem</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of channels"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">appGridItemImage</span>=<span class="hljs-string">"2rem"</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"item.icon"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span> /&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItemTitle</span>=<span class="hljs-string">"1rem"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">app-horizontal-grid</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> #<span class="hljs-attr">other</span>&gt;</span>  Other works<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span></code></pre><p>In ts file:</p><pre><code class="hljs ts"><span class="hljs-comment">// get the ActivatedRoute</span><span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> route: ActivatedRoute</span>) &#123;&#125;  ngOnInit() &#123;    <span class="hljs-keyword">this</span>.route.paramMap.subscribe(<span class="hljs-function"><span class="hljs-params">params</span> =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'path params: '</span>, params);      <span class="hljs-keyword">this</span>.selectedTabLink = params.get(<span class="hljs-string">'tabLink'</span>);    &#125;);    <span class="hljs-keyword">this</span>.route.queryParamMap.subscribe(<span class="hljs-function"><span class="hljs-params">params</span> =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'query params: '</span>, params);    &#125;);  &#125;</code></pre><p>The console output is:</p><br/>We can have many `router-outlet`, but only one can without name, others must have name.<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span></span><span class="hljs-tag">  [<span class="hljs-attr">routerLink</span>]=<span class="hljs-string">"['grand']"</span></span><span class="hljs-tag">  <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active"</span></span><span class="hljs-tag">  [<span class="hljs-attr">queryParams</span>]=<span class="hljs-string">"&#123; name: 'Joe', gender: 'male' &#125;"</span></span><span class="hljs-tag">  &gt;</span>link to grand<span class="hljs-tag">&lt;/<span class="hljs-name">a</span></span><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> [<span class="hljs-attr">routerLink</span>]=<span class="hljs-string">"[&#123; outlets: &#123; second: ['aux'] &#125; &#125;]"</span>&gt;</span>link to second<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"second"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span></code></pre><pre><code class="hljs ts">&#123;  path: <span class="hljs-string">':tabLink'</span>,  component: HomeDetailComponent,  children: [    &#123; path: <span class="hljs-string">'aux'</span>, component: HomeAuxComponent, outlet: <span class="hljs-string">'second'</span> &#125;,    &#123; path: <span class="hljs-string">'grand'</span>, component: HomeGrandComponent &#125;  ]&#125;</code></pre><h2 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h2><p>The detail about pipe can see <a href="https://angular.io/guide/pipes" target="_blank" rel="noopener">https://angular.io/guide/pipes</a>.</p><h3 id="Chaining-pipes"><a href="#Chaining-pipes" class="headerlink" title="Chaining pipes"></a>Chaining pipes</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>The chained hero's birthday is&#123;&#123; birthday | date | uppercase&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h3 id="Custom-pipes"><a href="#Custom-pipes" class="headerlink" title="Custom pipes"></a>Custom pipes</h3><p>See <a href="https://angular.cn/guide/pipes#custom-pipes" target="_blank" rel="noopener">https://angular.cn/guide/pipes#custom-pipes</a>.</p><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; Pipe, PipeTransform &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-meta">@Pipe</span>(&#123;name: <span class="hljs-string">'appAgo'</span>&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AgoPipe <span class="hljs-keyword">implements</span> PipeTransform &#123;  transform(value: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span> &#123;    <span class="hljs-keyword">if</span> (value) &#123;      <span class="hljs-keyword">const</span> seconds = <span class="hljs-built_in">Math</span>.floor((+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(value)) / <span class="hljs-number">1000</span>);      <span class="hljs-keyword">if</span> (seconds &lt; <span class="hljs-number">30</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">'A few seconds ago'</span>;      &#125;      <span class="hljs-keyword">const</span> intervals = &#123;        years: <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">365</span>,        months: <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">30</span>,        weeks: <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>,        days: <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>,        hours: <span class="hljs-number">3600</span>,        minutes: <span class="hljs-number">60</span>,        secondes: <span class="hljs-number">1</span>      &#125;;      <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> unitName <span class="hljs-keyword">in</span> intervals) &#123;        <span class="hljs-keyword">if</span> (intervals.hasOwnProperty(unitName)) &#123;          <span class="hljs-keyword">const</span> unitValue = intervals[unitName];            counter = <span class="hljs-built_in">Math</span>.floor(seconds / unitValue);          <span class="hljs-keyword">if</span> (counter &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;counter&#125;</span> <span class="hljs-subst">$&#123;unitName&#125;</span> ago`</span>;          &#125;                   &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> value;  &#125;&#125;</code></pre><p>Use the Custom pipes:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> &#123;\&#123; date | agoPipe &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HomeGrandComponent <span class="hljs-keyword">implements</span> OnInit &#123;  date: <span class="hljs-built_in">Date</span>;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123; &#125;    ngOnInit() &#123;    <span class="hljs-keyword">this</span>.date = <span class="hljs-keyword">this</span>.minusDays(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), <span class="hljs-number">60</span>);  &#125;  minusDays(date: <span class="hljs-built_in">Date</span>, days: <span class="hljs-built_in">number</span>) &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(date);    result.setDate(result.getDate() - days);    <span class="hljs-keyword">return</span> result;  &#125;&#125;</code></pre><h2 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"></a>Dependency Injection</h2><h3 id="What-is-DI"><a href="#What-is-DI" class="headerlink" title="What is DI?"></a>What is DI?</h3><br/>The instance created through DI is **singleton**. If component A and component B both inject a service, they are  using **the same instance**.<p>In angular, if we want to make some class injectable, we just need to add decorator <code>@Injectable()</code> above that class. </p><pre><code class="hljs ts"><span class="hljs-meta">@Injectable</span>()<span class="hljs-keyword">class</span> Product &#123;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">private</span> color: <span class="hljs-built_in">string</span></span>) &#123;&#125;  <span class="hljs-comment">// the above line combine the field declaration and constructor together.</span>&#125;<span class="hljs-meta">@Injectable</span>()<span class="hljs-keyword">class</span> PurchaseOrder &#123;  <span class="hljs-keyword">private</span> amount: <span class="hljs-built_in">number</span>;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> product: Product</span>) &#123;&#125;&#125;</code></pre><p>Use it in complex way:</p><pre><code class="hljs ts">ngOnInit() &#123;  <span class="hljs-keyword">this</span>.price = <span class="hljs-number">1234.56</span>;  <span class="hljs-keyword">const</span> injector = Injector.create(&#123;    providers: [      &#123;        provide: Product,        <span class="hljs-comment">//useClass: Product // inject a class</span>        <span class="hljs-comment">// or we can directly inject a specific object using useFactory</span>        useFactory: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product(<span class="hljs-string">'Phone'</span>, <span class="hljs-string">'black'</span>);        &#125;,        deps: []       &#125;,      &#123;        provide: PurchaseOrder,        useClass: PurchaseOrder,        deps: [Product]      &#125;    ]  &#125;);  <span class="hljs-built_in">console</span>.log(injector.get(Product));  <span class="hljs-built_in">console</span>.log(injector.get(PurchaseOrder));&#125;</code></pre><p>  Actually, we don’t need to use the complex way. The easy way is:</p><ol><li>add <code>@Injectable()</code> to the class</li><li>add <code>providers</code> in <code>module.ts</code><ul><li>if it is <code>useClass</code>, just add the class in the <code>providers</code> array: <code>providers: [PurchaseOrder]</code></li></ul></li></ol><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>The best practice is to create service for each module to do the data transfer job. Thus, to decouple data and components. Create a home service and see how to use DI to decouple data and our components.</p><p>Create <code>home.service.ts</code>:</p><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; Injectable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> &#123; TopMenu, ImageSlider, Channel &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'src/app/shared/components'</span>;<span class="hljs-meta">@Injectable</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HomeService &#123;  menus: TopMenu[] = [...];  imageSliders: ImageSlider[] = [...];    getTabs() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.menus; &#125;  getBanners() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.imageSliders; &#125;  getChannels() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.channels; &#125;&#125;</code></pre><p>In <code>HomeContainerComponent</code>:</p><pre><code class="hljs ts"><span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span><span class="hljs-params">   <span class="hljs-keyword">private</span> router: Router,</span><span class="hljs-params">   <span class="hljs-keyword">private</span> service: HomeService,</span><span class="hljs-params">   <span class="hljs-meta">@Inject</span>(token) <span class="hljs-keyword">private</span> baseUrl: <span class="hljs-built_in">string</span></span><span class="hljs-params"> </span>) &#123;&#125; ngOnInit() &#123;   <span class="hljs-keyword">this</span>.topMenus = <span class="hljs-keyword">this</span>.service.getTabs(); &#125;</code></pre><p>  In <code>HomeDetailComponent</code>:<br>  <pre><code class="hljs ts"> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> route: ActivatedRoute, <span class="hljs-keyword">private</span> service: HomeService</span>) &#123;&#125;ngOnInit() &#123;  <span class="hljs-comment">// ..</span>  <span class="hljs-keyword">this</span>.imagesSliders = <span class="hljs-keyword">this</span>.service.getSliders();  <span class="hljs-keyword">this</span>.channels = <span class="hljs-keyword">this</span>.service.getChannels();&#125;</code></pre></p><p>  MUST declare this service in <code>.module.ts</code>.<br>  <pre><code class="hljs ts">  <span class="hljs-meta">@NgModule</span>(&#123;  declarations: [...],  providers: [HomeService],  imports: [...]&#125;)</code></pre></p><h3 id="transfer-a-string-value"><a href="#transfer-a-string-value" class="headerlink" title="transfer a string value"></a>transfer a string value</h3><p>We can also just transfer a value using DI.</p><pre><code class="hljs ts">ngOnInit() &#123;  <span class="hljs-keyword">const</span> injector = <span class="hljs-keyword">new</span> Injector.create(&#123;    providers: [&#123;      &#123;        provider: <span class="hljs-string">'baseUrl'</span>,        useValue: <span class="hljs-string">'http://localhost'</span>      &#125;    &#125;]  &#125;)&#125;</code></pre><p>We can use a string ‘baseUrl’ to be the indicator of a injectable value, however in large project this may cause conflict. So Angular wants us to use Token as the string type indicator.</p><pre><code class="hljs ts"><span class="hljs-keyword">const</span> token = <span class="hljs-keyword">new</span> InjectionToken&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">'baseUrl'</span>);<span class="hljs-keyword">const</span> injector = <span class="hljs-keyword">new</span> Injector.create(&#123;  providers: [&#123;    &#123;      provide: token,      useValue: <span class="hljs-string">'http://localhost'</span>    &#125;  &#125;]&#125;)</code></pre><h3 id="DI-a-string-to-other-components"><a href="#DI-a-string-to-other-components" class="headerlink" title="DI a string to other components"></a>DI a string to other components</h3><ol><li>export it and declare in <code>.module.ts</code>.<pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">new</span> InjectionToken&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">'baseUrl'</span>);</code></pre></li></ol><pre><code class="hljs ts">providers: [HomeService, &#123; provide: token, useValue: <span class="hljs-string">'http://localhost'</span> &#125;]</code></pre><ol start="2"><li>use it with <code>@Inject(token)</code><pre><code class="hljs ts"><span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span><span class="hljs-params">  <span class="hljs-meta">@Inject</span>(token) <span class="hljs-keyword">private</span> baseUrl: <span class="hljs-built_in">string</span></span><span class="hljs-params"></span>) &#123;&#125;</code></pre></li></ol><h3 id="New-Injectable-syntax"><a href="#New-Injectable-syntax" class="headerlink" title="New @Injectable() syntax"></a>New <code>@Injectable()</code> syntax</h3><p>Add the decorator at the beginning of the service</p><pre><code class="hljs ts"><span class="hljs-meta">@Injectable</span>(&#123;  providedIn: <span class="hljs-string">'root'</span>&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HomeService&#123;&#125;</code></pre><p>Thus, we <strong>DO NOT</strong> need to add this service in <code>providers</code> array in the <code>.module.ts</code> .</p><h2 id="Dirty-Check-Change-Detection"><a href="#Dirty-Check-Change-Detection" class="headerlink" title="Dirty Check (Change Detection)"></a>Dirty Check (Change Detection)</h2><ul><li>What? view is refreshed when the data is changed.</li><li>When? when Dirty Check is triggered?<ul><li>browser events (e.g. click, mouseover, keyup,… )</li><li>setTimeout() and setInterval()</li><li>HTTP request</li></ul></li><li>How? Compare current status and new status.</li></ul><p>The Dirty Check (Change Detection) procedure is synchronous. And it is done twice by Angular framework.</p><p> Dirty Check (Change Detection) done before <code>AfterViewChecked</code> and <code>AfterViewInit</code> hook, so we should change property values in functions <code>ngAfterViewChecked()</code> and <code>ngAfterViewInit()</code>. </p><p> 子组件的所有的行为依赖于其自己定义的 @Input 属性。 而这个 @Input 属性是父组件在用。换言之，父组件的通过设置 @Input 属性，从而控制了子组件的所有行为。子组件并没有可以控制自己行为的方法。子组件所有的状态，都依赖于父组件的控制。子组件成为一个笨组件。==》 最佳实践：使用该方式，通过onPush策略。</p><p> The child component’s status is relay on parent component.</p><p> Change Detection done before <code>AfterViewChecked</code> and <code>AfterViewInit</code> hook, so we should change property values in functions <code>ngAfterViewChecked()</code> and <code>ngAfterViewInit()</code>. </p>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular 8: Content Projection, Router, Pipe and Dependency Injection</title>
    <link href="/2019/08/24/Angular-8-Content-Projection-Router-Pipe-and-Dependency-Injection/"/>
    <url>/2019/08/24/Angular-8-Content-Projection-Router-Pipe-and-Dependency-Injection/</url>
    
    <content type="html"><![CDATA[<!-- # Angular 8: Content Projection, Router, Pipe and Dependency Injection --><p>Angular 8 Demo Project Log and Experience Part 4.</p><h2 id="Issue-about-Component-nesting"><a href="#Issue-about-Component-nesting" class="headerlink" title="Issue about Component nesting"></a>Issue about Component nesting</h2><p>Component nesting is inevitable. Think about the structure:</p><ul><li><p>AppComponent</p><ul><li>ChildComponent<ul><li>GrandComponent<ul><li>GrandGrandComponent</li></ul></li></ul></li></ul><p>We can use <code>@Input()</code> and <code>@Output</code> to realize the data transfer between nesting components or between components and outside world. </p><p>However, if we need to transfer between <code>AppComponent</code> and <code>GrandGrandComponent</code>, we need to transfer the data or event in two middle components too.</p><p>This over nesting can lead to complexity and redundancy in our codes.</p><p>To avoid the redundant data and events brought by component nesting, we can use </p><ul><li>content projection </li><li>router </li><li>directive </li><li>service</li></ul></li></ul><h2 id="Content-Projection"><a href="#Content-Projection" class="headerlink" title="Content Projection"></a>Content Projection</h2><p>Using <code>ng-content</code>to realize content projection.</p><ul><li>what: dynamic content</li><li>syntax: <code>&lt;ng-content select=&quot;style classes / HTML tags / directives&quot;&gt;&lt;/ng-content&gt;</code></li><li>possible scenarios: <ul><li>display dynamic contents </li><li>as a component container</li></ul></li></ul><p>Previously we just call the ChildComponent in AppComponent, such as </p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-scrollable-tab</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-scrollable-tab</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">app-image-slider</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-image-slider</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">app-horizontal-grid</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-horizontal-grid</span>&gt;</span></code></pre><p>In <code>horizontal-grid.component.html</code>, we display the content as follow:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItem</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of channels"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><span class="hljs-tag">    [<span class="hljs-attr">src</span>]=<span class="hljs-string">"item.icon"</span></span><span class="hljs-tag">    <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span></span><span class="hljs-tag">    [<span class="hljs-attr">appGridItemImage</span>]=<span class="hljs-string">"'2rem'"</span></span><span class="hljs-tag">     /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItemTitle</span>=<span class="hljs-string">"0.6rem"</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre><p>This is the normal way to use components.</p><h3 id="Refactor-to-ng-content"><a href="#Refactor-to-ng-content" class="headerlink" title="Refactor to ng-content"></a>Refactor to <code>ng-content</code></h3><p>We now change the <code>horizontal-grid.component.html</code> to the code:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ng-content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-content</span>&gt;</span></code></pre><p>then, change the <code>app.component.html</code> to modify the <code>app-horizontal-grid</code>, just simply move the code from <code>horizontal-grid.component.html</code>, we also need to change some css or imports.</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-horizontal-grid</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItem</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of channels"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><span class="hljs-tag">    [<span class="hljs-attr">src</span>]=<span class="hljs-string">"item.icon"</span></span><span class="hljs-tag">    <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span></span><span class="hljs-tag">    [<span class="hljs-attr">appGridItemImage</span>]=<span class="hljs-string">"'2rem'"</span></span><span class="hljs-tag">     /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItemTitle</span>=<span class="hljs-string">"0.6rem"</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-horizontal-grid</span>&gt;</span></code></pre><p>Thus, the <strong>Content Projection</strong> DONE.</p><p>We can also use some syntax:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ng-content</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"span"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-content</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ng-content</span> <span class="hljs-attr">select</span>=<span class="hljs-string">".special"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-content</span>&gt;</span> <span class="hljs-comment">&lt;!-- special is class name --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ng-content</span> <span class="hljs-attr">select</span>=<span class="hljs-string">"[appGridItem]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-content</span>&gt;</span></code></pre><h2 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h2><p>Routes includes:</p><ul><li>path</li><li>component</li><li>child router</li></ul><h3 id="Router-to-Home-Page"><a href="#Router-to-Home-Page" class="headerlink" title="Router to Home Page"></a>Router to Home Page</h3><p>The best practice is to create individual file to deal with the routes.</p><p>Create <code>app-routing.module.ts</code>:</p><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; NgModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> &#123; RouterModule, Routes &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;<span class="hljs-keyword">import</span> &#123; HomeContainerComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./home'</span>;<span class="hljs-keyword">const</span> routes: Routes = [  &#123; path: <span class="hljs-string">''</span>, component: HomeContainerComponent &#125;];<span class="hljs-meta">@NgModule</span>(&#123;  imports: [RouterModule.forRoot(routes)],  exports: [RouterModule]&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppRoutingModule &#123;&#125;</code></pre><p>Each Route maps a URL path to a component. There are <strong>no leading slashes(/)</strong> in the path. The router parses and builds the final URL for you, allowing you to use both relative and absolute paths when navigating between application views.</p><p>In <code>app.component.html</code> add  <code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code>. Then, import <code>AppRoutingModule</code> and <code>HomeModule</code> in <code>app.module.ts</code>.</p><h3 id="Child-Router-in-Home-Page"><a href="#Child-Router-in-Home-Page" class="headerlink" title="Child Router in Home Page"></a>Child Router in Home Page</h3><p>Create a child router in the home page as follows. In  <code>home-routing.module.ts</code>,</p><pre><code class="hljs ts"><span class="hljs-keyword">const</span> routes: Routes = [  &#123;    path: <span class="hljs-string">'home'</span>,    component: HomeContainerComponent,    children: [      &#123; path: <span class="hljs-string">''</span>, redirectTo: <span class="hljs-string">'hot'</span>, pathMatch: <span class="hljs-string">'full'</span> &#125;,      &#123; path: <span class="hljs-string">':tabLink'</span>, component: HomeDetailComponent &#125;    ]  &#125;];<span class="hljs-meta">@NgModule</span>(&#123;  imports: [RouterModule.forChild(routes)],  exports: [RouterModule]&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HomeRoutingModule &#123;&#125;</code></pre><p>Beware we use <strong><code>RouterModule.forChild(routes)</code></strong>.</p><p>When we visit the path like <code>localhost:4200/home/</code>, it will redirectTo <code>hot</code>.</p><p>The <code>:tabLink</code> in the second route is a token for a route parameter. In a URL such as <code>/home/toy</code>, “toy” is the value of the id parameter. The corresponding HomeDetailComponent will use that value to find and present the content whose id is toy.</p><p>In <code>home-container.component.html</code>, we also need to remove the following code:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-image-slider</span> [<span class="hljs-attr">sliders</span>]=<span class="hljs-string">"imagesSliders"</span> #<span class="hljs-attr">imageSlider</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-image-slider</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">app-horizontal-grid</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItem</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of channels"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">appGridItemImage</span>=<span class="hljs-string">"2rem"</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"item.icon"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItemTitle</span>=<span class="hljs-string">"1rem"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-horizontal-grid</span>&gt;</span></code></pre><p>and add <code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code>.</p><p>Because all contents will display in <code>HomeDetailComponent</code>, we need to move the removed code to <code>home-container.component.html</code>.</p><h3 id="Params-in-Router-URL"><a href="#Params-in-Router-URL" class="headerlink" title="Params in Router URL"></a>Params in Router URL</h3><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><pre><code class="hljs ts">&#123; path: <span class="hljs-string">':tabLink'</span>, component: HomeDetailComponent &#125;</code></pre><h3 id="Activation"><a href="#Activation" class="headerlink" title="Activation"></a>Activation</h3><p>Two way to activate the router. </p><p>The <code>tab.link</code> means the <code>link</code> property in interface <code>tab</code>;</p><h4 id="use-routerLink-in-template-html-file"><a href="#use-routerLink-in-template-html-file" class="headerlink" title="use routerLink in template(html file)."></a>use routerLink in template(html file).</h4><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- single param --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> [<span class="hljs-attr">routerLink</span>=<span class="hljs-string">"['/home', tab.link]"</span>]&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!-- the params can also carry multi  key-value pairs--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> [<span class="hljs-attr">routerLink</span>=<span class="hljs-string">"['/home', tab.link, &#123;name: 'val1'&#125;]"</span>]&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-comment">&lt;!-- the params can also carry query params --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> [<span class="hljs-attr">routerLink</span>=<span class="hljs-string">"['/home', tab.link, [queryParams]=&#123;name: 'val1'&#125;]"</span>]&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><h4 id="handle-the-event-in-ts-file"><a href="#handle-the-event-in-ts-file" class="headerlink" title="handle the event in ts file"></a>handle the event in ts file</h4><pre><code class="hljs ts"><span class="hljs-comment">// single param </span><span class="hljs-keyword">this</span>.router.navigate([<span class="hljs-string">'home'</span>, tab.link]);<span class="hljs-comment">// the params can also carry multi key-value pairs</span><span class="hljs-keyword">this</span>.router.navigate([<span class="hljs-string">'home'</span>, tab.link, &#123;name: <span class="hljs-string">'val1'</span>&#125;]);<span class="hljs-comment">// the params can also carry query params</span><span class="hljs-keyword">this</span>.router.navigate([<span class="hljs-string">'home'</span>, tab.link, &#123;queryParams: &#123;name: <span class="hljs-string">'val1'</span>&#125;&#125;]);</code></pre><h3 id="Corresponding-URL"><a href="#Corresponding-URL" class="headerlink" title="Corresponding URL"></a>Corresponding URL</h3><ul><li><code>http://localhost:4200/home/sports</code></li><li>with key-value pairs: <code>http://localhost:4200/home/sports;name=val1</code></li><li>with query params: <code>http://localhost:4200/home/sports?name=val1</code></li></ul><h3 id="Read-Params-in-URL"><a href="#Read-Params-in-URL" class="headerlink" title="Read Params in URL"></a>Read Params in URL</h3><pre><code class="hljs ts"><span class="hljs-comment">// with or without key-value pair params</span><span class="hljs-keyword">this</span>.route.paramsMap.subscribe(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;...&#125;);<span class="hljs-comment">// with query params</span><span class="hljs-keyword">this</span>.route.queryParamsMap.subscribe(<span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;...&#125;);</code></pre><h3 id="Router-code-sample"><a href="#Router-code-sample" class="headerlink" title="Router code sample"></a>Router code sample</h3><p>In <code>home-container.component.html</code>, we use <code>app-scrollable-tab</code> component.</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-scrollable-tab</span></span><span class="hljs-tag">  [<span class="hljs-attr">menus</span>]=<span class="hljs-string">"topMenus"</span></span><span class="hljs-tag">  (<span class="hljs-attr">tabSelected</span>)=<span class="hljs-string">"handleTabSelected($event)"</span></span><span class="hljs-tag">  [<span class="hljs-attr">backgroundColor</span>]=<span class="hljs-string">"'#fff'"</span></span><span class="hljs-tag">  <span class="hljs-attr">titleColor</span>=<span class="hljs-string">"#3f3f3f"</span></span><span class="hljs-tag">  <span class="hljs-attr">titleActiveColor</span>=<span class="hljs-string">"red"</span></span><span class="hljs-tag">  <span class="hljs-attr">indicatorColor</span>=<span class="hljs-string">"red"</span></span><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-scrollable-tab</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span></code></pre><p>In <code>HomeContainerComponent</code>, we have a function to navigate the router:</p><pre><code class="hljs ts"><span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> router: Router</span>) &#123;&#125;handleTabSelected(topMenu: TopMenu) &#123;  <span class="hljs-keyword">this</span>.router.navigate([<span class="hljs-string">'home'</span>, topMenu.link]);&#125;</code></pre><p>Modify the <code>HomeDetailComponent</code> html:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"selectedTabLink === 'hot'; else other"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">app-image-slider</span> [<span class="hljs-attr">sliders</span>]=<span class="hljs-string">"imagesSliders"</span> #<span class="hljs-attr">imageSlider</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-image-slider</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">app-horizontal-grid</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItem</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of channels"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">appGridItemImage</span>=<span class="hljs-string">"2rem"</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"item.icon"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span> /&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItemTitle</span>=<span class="hljs-string">"1rem"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">app-horizontal-grid</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> #<span class="hljs-attr">other</span>&gt;</span>  Other works<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span></code></pre><p>In ts file:</p><pre><code class="hljs ts"><span class="hljs-comment">// get the ActivatedRoute</span><span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> route: ActivatedRoute</span>) &#123;&#125;  ngOnInit() &#123;    <span class="hljs-keyword">this</span>.route.paramMap.subscribe(<span class="hljs-function"><span class="hljs-params">params</span> =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'path params: '</span>, params);      <span class="hljs-keyword">this</span>.selectedTabLink = params.get(<span class="hljs-string">'tabLink'</span>);    &#125;);    <span class="hljs-keyword">this</span>.route.queryParamMap.subscribe(<span class="hljs-function"><span class="hljs-params">params</span> =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'query params: '</span>, params);    &#125;);  &#125;</code></pre><p>The console output is:</p><img src="/2019/08/24/Angular-8-Content-Projection-Router-Pipe-and-Dependency-Injection/router-query-params.png" srcset="/img/loading.gif" class="" title="Angular router query-params"><br/>We can have many `router-outlet`, but only one can without name, others must have name.<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span></span><span class="hljs-tag">  [<span class="hljs-attr">routerLink</span>]=<span class="hljs-string">"['grand']"</span></span><span class="hljs-tag">  <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active"</span></span><span class="hljs-tag">  [<span class="hljs-attr">queryParams</span>]=<span class="hljs-string">"&#123; name: 'Joe', gender: 'male' &#125;"</span></span><span class="hljs-tag">  &gt;</span>link to grand<span class="hljs-tag">&lt;/<span class="hljs-name">a</span></span><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> [<span class="hljs-attr">routerLink</span>]=<span class="hljs-string">"[&#123; outlets: &#123; second: ['aux'] &#125; &#125;]"</span>&gt;</span>link to second<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"second"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span></code></pre><pre><code class="hljs ts">&#123;  path: <span class="hljs-string">':tabLink'</span>,  component: HomeDetailComponent,  children: [    &#123; path: <span class="hljs-string">'aux'</span>, component: HomeAuxComponent, outlet: <span class="hljs-string">'second'</span> &#125;,    &#123; path: <span class="hljs-string">'grand'</span>, component: HomeGrandComponent &#125;  ]&#125;</code></pre><h2 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h2><p>The detail about pipe can see <a href="https://angular.io/guide/pipes" target="_blank" rel="noopener">https://angular.io/guide/pipes</a>.</p><h3 id="Chaining-pipes"><a href="#Chaining-pipes" class="headerlink" title="Chaining pipes"></a>Chaining pipes</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>The chained hero's birthday is&#123;&#123; birthday | date | uppercase&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h3 id="Custom-pipes"><a href="#Custom-pipes" class="headerlink" title="Custom pipes"></a>Custom pipes</h3><p>See <a href="https://angular.cn/guide/pipes#custom-pipes" target="_blank" rel="noopener">https://angular.cn/guide/pipes#custom-pipes</a>.</p><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; Pipe, PipeTransform &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-meta">@Pipe</span>(&#123;name: <span class="hljs-string">'appAgo'</span>&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AgoPipe <span class="hljs-keyword">implements</span> PipeTransform &#123;  transform(value: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span> &#123;    <span class="hljs-keyword">if</span> (value) &#123;      <span class="hljs-keyword">const</span> seconds = <span class="hljs-built_in">Math</span>.floor((+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(value)) / <span class="hljs-number">1000</span>);      <span class="hljs-keyword">if</span> (seconds &lt; <span class="hljs-number">30</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">'A few seconds ago'</span>;      &#125;      <span class="hljs-keyword">const</span> intervals = &#123;        years: <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">365</span>,        months: <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">30</span>,        weeks: <span class="hljs-number">3600</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>,        days: <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>,        hours: <span class="hljs-number">3600</span>,        minutes: <span class="hljs-number">60</span>,        secondes: <span class="hljs-number">1</span>      &#125;;      <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> unitName <span class="hljs-keyword">in</span> intervals) &#123;        <span class="hljs-keyword">if</span> (intervals.hasOwnProperty(unitName)) &#123;          <span class="hljs-keyword">const</span> unitValue = intervals[unitName];            counter = <span class="hljs-built_in">Math</span>.floor(seconds / unitValue);          <span class="hljs-keyword">if</span> (counter &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;counter&#125;</span> <span class="hljs-subst">$&#123;unitName&#125;</span> ago`</span>;          &#125;                   &#125;      &#125;    &#125;    <span class="hljs-keyword">return</span> value;  &#125;&#125;</code></pre><p>Use the Custom pipes:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> &#123;\&#123; date | agoPipe &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HomeGrandComponent <span class="hljs-keyword">implements</span> OnInit &#123;  date: <span class="hljs-built_in">Date</span>;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123; &#125;    ngOnInit() &#123;    <span class="hljs-keyword">this</span>.date = <span class="hljs-keyword">this</span>.minusDays(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(), <span class="hljs-number">60</span>);  &#125;  minusDays(date: <span class="hljs-built_in">Date</span>, days: <span class="hljs-built_in">number</span>) &#123;    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(date);    result.setDate(result.getDate() - days);    <span class="hljs-keyword">return</span> result;  &#125;&#125;</code></pre><h2 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"></a>Dependency Injection</h2><h3 id="What-is-DI"><a href="#What-is-DI" class="headerlink" title="What is DI?"></a>What is DI?</h3><img src="/2019/08/24/Angular-8-Content-Projection-Router-Pipe-and-Dependency-Injection/DI.png" srcset="/img/loading.gif" class="" title="Angular Dependency Injection"><br/>The instance created through DI is **singleton**. If component A and component B both inject a service, they are  using **the same instance**.<p>In angular, if we want to make some class injectable, we just need to add decorator <code>@Injectable()</code> above that class. </p><pre><code class="hljs ts"><span class="hljs-meta">@Injectable</span>()<span class="hljs-keyword">class</span> Product &#123;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> name: <span class="hljs-built_in">string</span>, <span class="hljs-keyword">private</span> color: <span class="hljs-built_in">string</span></span>) &#123;&#125;  <span class="hljs-comment">// the above line combine the field declaration and constructor together.</span>&#125;<span class="hljs-meta">@Injectable</span>()<span class="hljs-keyword">class</span> PurchaseOrder &#123;  <span class="hljs-keyword">private</span> amount: <span class="hljs-built_in">number</span>;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> product: Product</span>) &#123;&#125;&#125;</code></pre><p>Use it in complex way:</p><pre><code class="hljs ts">ngOnInit() &#123;  <span class="hljs-keyword">this</span>.price = <span class="hljs-number">1234.56</span>;  <span class="hljs-keyword">const</span> injector = Injector.create(&#123;    providers: [      &#123;        provide: Product,        <span class="hljs-comment">//useClass: Product // inject a class</span>        <span class="hljs-comment">// or we can directly inject a specific object using useFactory</span>        useFactory: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product(<span class="hljs-string">'Phone'</span>, <span class="hljs-string">'black'</span>);        &#125;,        deps: []       &#125;,      &#123;        provide: PurchaseOrder,        useClass: PurchaseOrder,        deps: [Product]      &#125;    ]  &#125;);  <span class="hljs-built_in">console</span>.log(injector.get(Product));  <span class="hljs-built_in">console</span>.log(injector.get(PurchaseOrder));&#125;</code></pre><p>  Actually, we don’t need to use the complex way. The easy way is:</p><ol><li>add <code>@Injectable()</code> to the class</li><li>add <code>providers</code> in <code>module.ts</code><ul><li>if it is <code>useClass</code>, just add the class in the <code>providers</code> array: <code>providers: [PurchaseOrder]</code></li></ul></li></ol><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>The best practice is to create service for each module to do the data transfer job. Thus, to decouple data and components. Create a home service and see how to use DI to decouple data and our components.</p><p>Create <code>home.service.ts</code>:</p><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; Injectable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-keyword">import</span> &#123; TopMenu, ImageSlider, Channel &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'src/app/shared/components'</span>;<span class="hljs-meta">@Injectable</span>()<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HomeService &#123;  menus: TopMenu[] = [...];  imageSliders: ImageSlider[] = [...];    getTabs() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.menus; &#125;  getBanners() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.imageSliders; &#125;  getChannels() &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.channels; &#125;&#125;</code></pre><p>In <code>HomeContainerComponent</code>:</p><pre><code class="hljs ts"><span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span><span class="hljs-params">   <span class="hljs-keyword">private</span> router: Router,</span><span class="hljs-params">   <span class="hljs-keyword">private</span> service: HomeService,</span><span class="hljs-params">   <span class="hljs-meta">@Inject</span>(token) <span class="hljs-keyword">private</span> baseUrl: <span class="hljs-built_in">string</span></span><span class="hljs-params"> </span>) &#123;&#125; ngOnInit() &#123;   <span class="hljs-keyword">this</span>.topMenus = <span class="hljs-keyword">this</span>.service.getTabs(); &#125;</code></pre><p>  In <code>HomeDetailComponent</code>:<br>  <pre><code class="hljs ts"> <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> route: ActivatedRoute, <span class="hljs-keyword">private</span> service: HomeService</span>) &#123;&#125;ngOnInit() &#123;  <span class="hljs-comment">// ..</span>  <span class="hljs-keyword">this</span>.imagesSliders = <span class="hljs-keyword">this</span>.service.getSliders();  <span class="hljs-keyword">this</span>.channels = <span class="hljs-keyword">this</span>.service.getChannels();&#125;</code></pre></p><p>  MUST declare this service in <code>.module.ts</code>.<br>  <pre><code class="hljs ts">  <span class="hljs-meta">@NgModule</span>(&#123;  declarations: [...],  providers: [HomeService],  imports: [...]&#125;)</code></pre></p><h3 id="transfer-a-string-value"><a href="#transfer-a-string-value" class="headerlink" title="transfer a string value"></a>transfer a string value</h3><p>We can also just transfer a value using DI.</p><pre><code class="hljs ts">ngOnInit() &#123;  <span class="hljs-keyword">const</span> injector = <span class="hljs-keyword">new</span> Injector.create(&#123;    providers: [&#123;      &#123;        provider: <span class="hljs-string">'baseUrl'</span>,        useValue: <span class="hljs-string">'http://localhost'</span>      &#125;    &#125;]  &#125;)&#125;</code></pre><p>We can use a string ‘baseUrl’ to be the indicator of a injectable value, however in large project this may cause conflict. So Angular wants us to use Token as the string type indicator.</p><pre><code class="hljs ts"><span class="hljs-keyword">const</span> token = <span class="hljs-keyword">new</span> InjectionToken&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">'baseUrl'</span>);<span class="hljs-keyword">const</span> injector = <span class="hljs-keyword">new</span> Injector.create(&#123;  providers: [&#123;    &#123;      provide: token,      useValue: <span class="hljs-string">'http://localhost'</span>    &#125;  &#125;]&#125;)</code></pre><h3 id="DI-a-string-to-other-components"><a href="#DI-a-string-to-other-components" class="headerlink" title="DI a string to other components"></a>DI a string to other components</h3><ol><li>export it and declare in <code>.module.ts</code>.<pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">new</span> InjectionToken&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">'baseUrl'</span>);</code></pre></li></ol><pre><code class="hljs ts">providers: [HomeService, &#123; provide: token, useValue: <span class="hljs-string">'http://localhost'</span> &#125;]</code></pre><ol start="2"><li>use it with <code>@Inject(token)</code><pre><code class="hljs ts"><span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span><span class="hljs-params">  <span class="hljs-meta">@Inject</span>(token) <span class="hljs-keyword">private</span> baseUrl: <span class="hljs-built_in">string</span></span><span class="hljs-params"></span>) &#123;&#125;</code></pre></li></ol><h3 id="New-Injectable-syntax"><a href="#New-Injectable-syntax" class="headerlink" title="New @Injectable() syntax"></a>New <code>@Injectable()</code> syntax</h3><p>Add the decorator at the beginning of the service</p><pre><code class="hljs ts"><span class="hljs-meta">@Injectable</span>(&#123;  providedIn: <span class="hljs-string">'root'</span>&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HomeService&#123;&#125;</code></pre><p>Thus, we <strong>DO NOT</strong> need to add this service in <code>providers</code> array in the <code>.module.ts</code> .</p><h2 id="Dirty-Check-Change-Detection"><a href="#Dirty-Check-Change-Detection" class="headerlink" title="Dirty Check (Change Detection)"></a>Dirty Check (Change Detection)</h2><ul><li>What? view is refreshed when the data is changed.</li><li>When? when Dirty Check is triggered?<ul><li>browser events (e.g. click, mouseover, keyup,… )</li><li>setTimeout() and setInterval()</li><li>HTTP request</li></ul></li><li>How? Compare current status and new status.</li></ul><p>The Dirty Check (Change Detection) procedure is synchronous. And it is done twice by Angular framework.</p><img src="/2019/08/24/Angular-8-Content-Projection-Router-Pipe-and-Dependency-Injection/dirty-check.png" srcset="/img/loading.gif" class="" title="Angular dirty check"><p> Dirty Check (Change Detection) done before <code>AfterViewChecked</code> and <code>AfterViewInit</code> hook, so we should change property values in functions <code>ngAfterViewChecked()</code> and <code>ngAfterViewInit()</code>. </p><p> 子组件的所有的行为依赖于其自己定义的 @Input 属性。 而这个 @Input 属性是父组件在用。换言之，父组件的通过设置 @Input 属性，从而控制了子组件的所有行为。子组件并没有可以控制自己行为的方法。子组件所有的状态，都依赖于父组件的控制。子组件成为一个笨组件。==》 最佳实践：使用该方式，通过onPush策略。</p><p> The child component’s status is relay on parent component.</p><p> Change Detection done before <code>AfterViewChecked</code> and <code>AfterViewInit</code> hook, so we should change property values in functions <code>ngAfterViewChecked()</code> and <code>ngAfterViewInit()</code>. </p>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular 8: Decorator, Directiveand and Style Binding/Event Binding</title>
    <link href="/2019/08/23/Angular-8-Decorator-Directiveand-and-Style-Binding-Event-Binding/"/>
    <url>/2019/08/23/Angular-8-Decorator-Directiveand-and-Style-Binding-Event-Binding/</url>
    
    <content type="html"><![CDATA[<!-- # Angular 8: Decorator, Directiveand and Style Binding/Event Binding --><p> Angular 8 Demo Project Log and Experience Part 3.</p><h2 id="Decorator-Annotation"><a href="#Decorator-Annotation" class="headerlink" title="Decorator(Annotation)"></a>Decorator(Annotation)</h2><p>Annotation or Decorator is a function, which returns a function.</p><h3 id="Create-a-customer-decorator-Emoji"><a href="#Create-a-customer-decorator-Emoji" class="headerlink" title="Create a customer decorator @Emoji"></a>Create a customer decorator @Emoji</h3><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Emoji</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target: object, key: <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> val = target[key]; <span class="hljs-comment">// let val get the target's value. key is the index.</span>    <span class="hljs-keyword">const</span> getter = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> val;    &#125;;    <span class="hljs-comment">// user setter to change the value</span>    <span class="hljs-keyword">const</span> setter = <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;      val = <span class="hljs-string">`😂 <span class="hljs-subst">$&#123;value&#125;</span> 😂`</span>;    &#125;;    <span class="hljs-comment">// append the property to the target</span>    <span class="hljs-built_in">Object</span>.defineProperty(target, key, &#123;      <span class="hljs-keyword">get</span>: getter,      <span class="hljs-keyword">set</span>: setter,      enumerable: <span class="hljs-literal">true</span>,      configurable: <span class="hljs-literal">true</span>    &#125;);  &#125;;&#125;</code></pre><p>Thus, this decorator <code>@Emoji</code> can be import to other component and use it.</p><pre><code class="hljs ts"><span class="hljs-meta">@Emoji</span>() result = <span class="hljs-string">'Hello'</span>;</code></pre><p>The result output is <code>😂 Hello 😂</code>;</p><h3 id="Create-a-customer-decorator-Confirmable-’…’"><a href="#Create-a-customer-decorator-Confirmable-’…’" class="headerlink" title="Create a customer decorator @Confirmable(’…’)"></a>Create a customer decorator @Confirmable(’…’)</h3><p>This decorator contains parameter.</p><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Confirmable</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target: object, key: <span class="hljs-built_in">string</span>, descriptor: PropertyDescriptor</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> original = descriptor.value;    descriptor.value = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args: <span class="hljs-built_in">any</span></span>) </span>&#123;      <span class="hljs-keyword">const</span> allow = <span class="hljs-built_in">window</span>.confirm(message);      <span class="hljs-keyword">if</span> (allow) &#123;        <span class="hljs-keyword">const</span> result = original.apply(args);        <span class="hljs-keyword">return</span> result;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;;    <span class="hljs-keyword">return</span> descriptor;  &#125;;&#125;</code></pre><p>To use this decorator.</p><pre><code class="hljs ts"><span class="hljs-meta">@Confirmable</span>(<span class="hljs-string">'Are you sure to do something?'</span>)handleClick() &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'handle click works'</span>);&#125;</code></pre><p>When clicking the button, we want to pop up a window to warn our user.</p><h2 id="Directive"><a href="#Directive" class="headerlink" title="Directive"></a>Directive</h2><h3 id="Kinds"><a href="#Kinds" class="headerlink" title="Kinds"></a>Kinds</h3><p>There are three kinds of directives in Angular:</p><ul><li>Components: directives with a template.</li><li>Structural directives: change the DOM layout by adding and removing DOM elements. <strong>Change the structure of the view</strong>, <code>ngFor</code>, <code>ngIf</code>, <code>ngSwitch</code>.</li><li>Attribute directives: change the appearance or behavior of an element, component, or another directive.<strong>Used as attributes of elements</strong>, <code>ngClass</code>, <code>ngStyle</code>, <code>ngModel</code>.</li></ul><h3 id="Create-Custom-Directives"><a href="#Create-Custom-Directives" class="headerlink" title="Create Custom Directives"></a>Create Custom Directives</h3><p>Create a file <code>gird-item.directive.ts</code>, in this file use a shortcut <code>ng-directive</code> to generate a directive. Then a template can be generated as below.</p><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; Directive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-meta">@Directive</span>(&#123;  selector: <span class="hljs-string">'appGridItem'</span>&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> GridItemDirective &#123;&#125;</code></pre><p>The selector name is wrong, it need to be an <strong>Attribute</strong>. Fix the problem to change the name to attribute:</p><pre><code class="hljs ts"><span class="hljs-meta">@Directive</span>(&#123;  selector: <span class="hljs-string">'[appGridItem]'</span>,&#125;)</code></pre><p>Also, we need to add its deceleration in <code>shared.component.ts</code> and also export it.</p><p>The code to implement the directive:</p><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; Directive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<span class="hljs-meta">@Directive</span>(&#123;  selector: <span class="hljs-string">'[appGridItem]'</span>&#125;)<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> GridItemDirective &#123;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> elr: ElementRef, <span class="hljs-keyword">private</span> rd2: Renderer2</span>) &#123;    <span class="hljs-keyword">this</span>.rd2.setStyle(<span class="hljs-keyword">this</span>.elr.nativeElement, <span class="hljs-string">'display'</span>, <span class="hljs-string">'grid'</span>);    <span class="hljs-keyword">this</span>.rd2.setStyle(      <span class="hljs-keyword">this</span>.elr.nativeElement,      <span class="hljs-string">'grid-template'</span>,      <span class="hljs-string">`'image' 'title'`</span>    );    <span class="hljs-keyword">this</span>.rd2.setStyle(<span class="hljs-keyword">this</span>.elr.nativeElement, <span class="hljs-string">'place-itmes'</span>, <span class="hljs-string">'center'</span>);    <span class="hljs-keyword">this</span>.rd2.setStyle(<span class="hljs-keyword">this</span>.elr.nativeElement, <span class="hljs-string">'width'</span>, <span class="hljs-string">'4rem'</span>);  &#125;&#125;</code></pre><p>The best practice is to set styles in the <code>ngOnInit</code>, not in the <code>constructor</code>.</p><pre><code class="hljs ts"><span class="hljs-keyword">constructor</span> (<span class="hljs-params"></span><span class="hljs-params">    <span class="hljs-keyword">private</span> elr: ElementRef,</span><span class="hljs-params">    <span class="hljs-keyword">private</span> rd2: Renderer2</span><span class="hljs-params">  </span>) &#123;&#125;ngOnInit() &#123;    <span class="hljs-keyword">this</span>.rd2.setStyle(<span class="hljs-keyword">this</span>.elr.nativeElement, <span class="hljs-string">'display'</span>, <span class="hljs-string">'grid'</span>);    <span class="hljs-keyword">this</span>.rd2.setStyle(<span class="hljs-keyword">this</span>.elr.nativeElement, <span class="hljs-string">'grid-template-areas'</span>, <span class="hljs-string">`'image' 'title'`</span>);    <span class="hljs-keyword">this</span>.rd2.setStyle(<span class="hljs-keyword">this</span>.elr.nativeElement, <span class="hljs-string">'place-items'</span>, <span class="hljs-string">'center'</span>);    <span class="hljs-keyword">this</span>.rd2.setStyle(<span class="hljs-keyword">this</span>.elr.nativeElement, <span class="hljs-string">'width'</span>, <span class="hljs-string">'4rem'</span>);  &#125;</code></pre><h3 id="Use-Directives"><a href="#Use-Directives" class="headerlink" title="Use Directives"></a>Use Directives</h3><p>We can create <code>appGridItemImage</code> and <code>appGridItemTitle</code> directives.</p><p>Directives are like properties. Now we can use these directives in the template of <code>HorizontalGridComponent</code>.</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">appGridItem</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of channels"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"item.imgUrl"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span> <span class="hljs-attr">appGridItemImage</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItemTitle</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Directives like properties, which can be applied to HTML tags.</p><h2 id="Style-Binding-Event-Binding-use-Directive"><a href="#Style-Binding-Event-Binding-use-Directive" class="headerlink" title="Style Binding / Event Binding use Directive"></a>Style Binding / Event Binding use Directive</h2><p> There is no template in directive. Directive needs a host(an element). In Angular, <code>@HostBinding</code> can be used to bind attributes and styles to host, <code>@HostListener</code> can be used to bind events to host.</p><h3 id="HostBinding"><a href="#HostBinding" class="headerlink" title="@HostBinding"></a>@HostBinding</h3><p>We use <code>rd2.setStyle</code> to set styles of host, now we can use <code>@HostBinding</code> to refactor.</p><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> GridItemDirective &#123;   <span class="hljs-meta">@HostBinding</span>(<span class="hljs-string">'style.display'</span>) display = <span class="hljs-string">'grid'</span>;  <span class="hljs-meta">@HostBinding</span>(<span class="hljs-string">'style.grid-template-areas'</span>) template = <span class="hljs-string">`'image' 'title'`</span>;  <span class="hljs-meta">@HostBinding</span>(<span class="hljs-string">'style.place-items'</span>) align = <span class="hljs-string">'center'</span>;  <span class="hljs-meta">@HostBinding</span>(<span class="hljs-string">'style.width'</span>) width = <span class="hljs-string">'4rem'</span>;&#125;</code></pre><h3 id="HostListener"><a href="#HostListener" class="headerlink" title="@HostListener"></a>@HostListener</h3><p>It accepts two params, one is eventName(The CSS event to listen for), another is event data (args, A set of arguments to pass to the handler method when the event occurs).</p><pre><code class="hljs ts"><span class="hljs-meta">@HostListener</span>(<span class="hljs-string">'click'</span>, [<span class="hljs-string">'$event.target'</span>]) onClick(ev) &#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'event: '</span>, ev);&#125;</code></pre><p> We don’t need to add additional event binding in template. What we do is just click the image, the <code>@HostListener</code> is listing to the <strong>click</strong> event.</p> <pre><code class="hljs html"> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">appGridItem</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of channels"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"item.icon"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span> </span><span class="hljs-tag">       [<span class="hljs-attr">appGridItemImage</span>]=<span class="hljs-string">"'4rem'"</span> </span><span class="hljs-tag">       [<span class="hljs-attr">fitMode</span>]=<span class="hljs-string">"'cover'"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">appGridItemTitle</span>=<span class="hljs-string">"0.6rem"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h2 id="host"><a href="#host" class="headerlink" title=":host"></a>:host</h2><p>:host is used to design component styles in .component.css. It is a pseudo-classes selector. For example,</p><pre><code class="hljs css"><span class="hljs-selector-pseudo">:host</span> &#123;    <span class="hljs-attribute">display</span>: flex;    <span class="hljs-attribute">justify-content</span>: center;&#125;</code></pre><p>The pattern defined by :host is applied to the component itself.</p>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular 8: Lifecycle Hooks, Template reference variables and Carousel</title>
    <link href="/2019/08/22/Angular-8-Lifecycle-Hooks-Template-reference-variables-and-Carousel/"/>
    <url>/2019/08/22/Angular-8-Lifecycle-Hooks-Template-reference-variables-and-Carousel/</url>
    
    <content type="html"><![CDATA[<!-- # Angular 8: Lifecycle Hooks, Template reference variables and Carousel --><p>Angular 8 Demo Project Log and Experience Part 2.</p><h2 id="Lifecycle-Hooks"><a href="#Lifecycle-Hooks" class="headerlink" title="Lifecycle Hooks"></a>Lifecycle Hooks</h2><p>The general Angular life cycle is below:</p><img src="/2019/08/22/Angular-8-Lifecycle-Hooks-Template-reference-variables-and-Carousel/Angular-Lifecycle-hooks-order.png" srcset="/img/loading.gif" class="" title="Angular Lifecycle hooks order"><br/><br/><p>This life cycle has different hooks:</p><img src="/2019/08/22/Angular-8-Lifecycle-Hooks-Template-reference-variables-and-Carousel/lifecycle-hooks.png" srcset="/img/loading.gif" class="" title="Angular Lifecycle hooks"><ul><li><p><code>constructor()</code>: This will always be called at first.</p></li><li><p><code>ngOnChanges(changes: SimpleChanges): void {}</code>: Check changes of the component.</p><ul><li>Called before any other lifecycle hook. Use it to inject dependencies, but avoid any serious work here.</li><li>Called when input properties of component changes. changes is a dict type object <code>(key: property name, value: SimpleChange)</code>.</li><li>Add implements <code>OnChanges</code> to the class.</li></ul></li><li><p><code>ngOnInit()</code>: Initialize the component. In this func we can safely use properties and methods of component.</p></li><li><p><code>ngAfterContentInit(): void {}</code>: Initialize the content of component.</p><ul><li>Called after <code>ngOnInit</code> when the component’s or directive’s content has been initialized.</li><li>Add implements <code>AfterContentInit</code> to the class.</li><li>By default, our component doesn’t support nesting. That is in the below example the Hello will not be displayed in the view. To display it, we add an <code>&lt;ng-content&gt;</code> tag in the <code>ScrollableTabComponent</code> to let the component have a content.</li></ul></li><li><p><code>ngAfterContentChecked(): void {}</code>: Check invalid data in the content of component. Called after every check of the component’s or directive’s content.</p></li><li><p><code>ngAfterViewInit()</code>: Initialize the view of the component.</p><ul><li>View includes the component and all its sub-components.</li><li>Called after ngAfterContentInit when the component’s view has been initialized. Applies to components only.</li></ul></li><li><p><code>ngAfterViewChecked(): void {}</code>: Check invalid data in the view. Called after every check of the component’s view. Applies to components only.</p></li><li><p><code>ngOnCheck(): void {}</code>: Check invalid data of component.</p><ul><li>Called every time that the input properties of a component or a directive are checked.</li><li>Use it to extend change detection by performing a custom check.</li></ul></li><li><p><code>ngOnDestroy(): void {}</code>: Called once, before the instance is destroyed. How to trigger this directive. We can use <code>*ngIf</code>, if it is falsy the component will be destroyed. For example, This is used when we want to do some clearance, e.g. when setting interval.</p></li></ul><h3 id="Code-example-and-output"><a href="#Code-example-and-output" class="headerlink" title="Code example and output"></a>Code example and output</h3><p>Add the code in <code>ScrollableTabComponent</code></p><pre><code class="hljs ts"><span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'constructor called'</span>); &#125; ngOnChanges(changes: SimpleChanges): <span class="hljs-built_in">void</span> &#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Component input changes, call ngOnChanges: '</span>, changes); &#125; ngOnInit() &#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ngOnInit called'</span>); &#125; ngAfterContentInit(): <span class="hljs-built_in">void</span> &#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ngAfterContentInit called'</span>); &#125; ngAfterContentChecked(): <span class="hljs-built_in">void</span> &#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ngAfterContentChecked called'</span>); &#125; ngAfterViewInit(): <span class="hljs-built_in">void</span> &#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ngAfterViewInit called'</span>); &#125; ngAfterViewChecked(): <span class="hljs-built_in">void</span> &#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ngAfterViewChecked called'</span>); &#125; ngOnDestroy(): <span class="hljs-built_in">void</span> &#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ngOnDestroy'</span>); &#125;</code></pre><p>The output is:</p><img src="/2019/08/22/Angular-8-Lifecycle-Hooks-Template-reference-variables-and-Carousel/lifecycle-hooks-output.png" srcset="/img/loading.gif" class="" title="Angular Lifecycle hooks output"><h2 id="Template-reference-variables"><a href="#Template-reference-variables" class="headerlink" title="Template reference variables"></a>Template reference variables</h2><h3 id="Template-reference-variables-I"><a href="#Template-reference-variables-I" class="headerlink" title="Template reference variables I"></a>Template reference variables I</h3><p>We can use <code>#refName</code> to name the reference of template element. For example,</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> #<span class="hljs-attr">helloDiv</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>Since the scope of the <code>refName</code> is global, so it should be unique. Then we can use this <code>refName</code> as the reference of template element. In the following example, the <code>@ViewChild</code> is a selector, used to find the DOM element or component. ElementRef is a wrapper class of DOM element. Since DOM element is not an Angular class, so a wrapper class is needed to conveniently use and identify different types of DOM elements.</p><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent &#123;  <span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">'helloDiv'</span>) helloDivRef: ElementRef;&#125;</code></pre><h3 id="Template-reference-variables-II"><a href="#Template-reference-variables-II" class="headerlink" title="Template reference variables II"></a>Template reference variables II</h3><p>we can also use <code>type name</code>. For example,</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-image-slider</span> [<span class="hljs-attr">sliders</span>]=<span class="hljs-string">"imageSliders"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-image-slider</span>&gt;</span></code></pre><pre><code class="hljs ts"><span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">'ImageSliderComponent'</span>) imageSlider: ImageSliderComponent;</code></pre><p>If we want to refer to multiple elements, we can use <code>@ViewChildren(refName or typeName)</code>. Then declaration type should be <code>QueryList&lt;?&gt;</code>.For example,</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><span class="hljs-tag">  #<span class="hljs-attr">img</span></span><span class="hljs-tag">  *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let slider of sliders"</span></span><span class="hljs-tag">  [<span class="hljs-attr">src</span>]=<span class="hljs-string">"slider.imgUrl"</span></span><span class="hljs-tag">  [<span class="hljs-attr">alt</span>]=<span class="hljs-string">"slider.caption"</span></span><span class="hljs-tag">/&gt;</span></code></pre><pre><code class="hljs ts"><span class="hljs-meta">@ViewChildren</span>(<span class="hljs-string">'img'</span>) imgs: QueryList&lt;ElementRef&gt;;</code></pre><p>Then we can change style of DOM elements. Changing properties of DOM elements is always not recommended in Angular, since this may cause Injection. Instead we can use <code>Renderer2</code> module. For example,</p><pre><code class="hljs ts"><span class="hljs-keyword">constructor</span> (<span class="hljs-params"><span class="hljs-keyword">private</span> rd2: Renderer2</span>) &#123;&#125;<span class="hljs-meta">@ViewChildren</span>(<span class="hljs-string">'img'</span>) imgs: QueryList&lt;ElementRef&gt;;ngAfterViewInit () &#123;  <span class="hljs-keyword">this</span>.imgs.forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;    <span class="hljs-keyword">this</span>.rd2.setStyle(item.nativeElement, <span class="hljs-string">'height'</span>, <span class="hljs-string">'100px'</span>)  &#125;);&#125;</code></pre><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul><li><code>@ViewChild()</code> can be used to ref the view elements. These elements can be Angular component or DOM elements.</li><li>In AfterViewInit, we can safely use elements referred by <code>@ViewChild()</code>.</li><li>It’s better to use <code>Renderer2</code> to operate DOM elements.</li></ul><h2 id="Carousel-ImageSliderComponent"><a href="#Carousel-ImageSliderComponent" class="headerlink" title="Carousel: ImageSliderComponent"></a>Carousel: ImageSliderComponent</h2><p>Use <code>setInterval()</code> method, letting each img scrollLeft a specific length every 2 seconds. We did this in <code>ngAfterViewInit()</code>.</p><p>Use <code>Renderer2</code> to safely change the property, <strong>DO NOT</strong> use DOM directly.</p><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ImageSlider &#123;  imgUrl: <span class="hljs-built_in">string</span>;  link: <span class="hljs-built_in">string</span>;  caption: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ImageSliderComponent <span class="hljs-keyword">implements</span> OnInit, AfterViewInit, OnDestroy &#123;  <span class="hljs-meta">@Input</span>() sliders: ImageSlider[] = [];  <span class="hljs-meta">@Input</span>() sliderHeight = <span class="hljs-string">'160xp'</span>;  <span class="hljs-meta">@Input</span>() intervalBySeconds = <span class="hljs-number">2</span>;  selectIndex = <span class="hljs-number">0</span>;  intervalId;  <span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">'imageSlider'</span>, &#123; <span class="hljs-keyword">static</span>: <span class="hljs-literal">true</span> &#125;) imgSlider: ElementRef;  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> rd2: Renderer2</span>) &#123;&#125;  ngOnInit() &#123;&#125;  ngAfterViewInit(): <span class="hljs-built_in">void</span> &#123;    <span class="hljs-keyword">this</span>.intervalId = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">this</span>.rd2.setProperty(        <span class="hljs-keyword">this</span>.imgSlider.nativeElement,        <span class="hljs-string">'scrollLeft'</span>,        (<span class="hljs-keyword">this</span>.getIndex(++<span class="hljs-keyword">this</span>.selectIndex) *          <span class="hljs-keyword">this</span>.imgSlider.nativeElement.scrollWidth) /          <span class="hljs-keyword">this</span>.sliders.length      );    &#125;, <span class="hljs-keyword">this</span>.intervalBySeconds * <span class="hljs-number">1000</span>);  &#125;  getIndex(idx: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> &#123;    <span class="hljs-keyword">return</span> idx &gt;= <span class="hljs-number">0</span>      ? idx % <span class="hljs-keyword">this</span>.sliders.length      : <span class="hljs-keyword">this</span>.sliders.length - (<span class="hljs-built_in">Math</span>.abs(idx) % <span class="hljs-keyword">this</span>.sliders.length);  &#125;  handleScroll(ev: <span class="hljs-built_in">any</span>) &#123;    <span class="hljs-keyword">const</span> ratio =      (ev.target.scrollLeft * <span class="hljs-keyword">this</span>.sliders.length) / ev.target.scrollWidth;    <span class="hljs-keyword">this</span>.selectIndex = <span class="hljs-built_in">Math</span>.round(ratio);  &#125;  ngOnDestroy(): <span class="hljs-built_in">void</span> &#123;    clearInterval(<span class="hljs-keyword">this</span>.intervalId);  &#125;&#125;</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span> [<span class="hljs-attr">ngStyle</span>]=<span class="hljs-string">"&#123; height: sliderHeight &#125;"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"image-slider"</span> (<span class="hljs-attr">scroll</span>)=<span class="hljs-string">"handleScroll($event)"</span> #<span class="hljs-attr">imageSlider</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span><span class="hljs-tag">      #<span class="hljs-attr">img</span></span><span class="hljs-tag">      *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let slider of sliders"</span></span><span class="hljs-tag">      [<span class="hljs-attr">src</span>]=<span class="hljs-string">"slider.imgUrl"</span></span><span class="hljs-tag">      [<span class="hljs-attr">alt</span>]=<span class="hljs-string">"slider.caption"</span></span><span class="hljs-tag">    /&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav-section"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span></span><span class="hljs-tag">      *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let _ of sliders; let idx = index"</span></span><span class="hljs-tag">      [<span class="hljs-attr">ngClass</span>]=<span class="hljs-string">"&#123; 'slider-button-select': idx === selectIndex &#125;"</span></span><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">"slider-button"</span></span><span class="hljs-tag">    &gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs css"><span class="hljs-selector-class">.nav-section</span> &#123;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.5</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000000</span>;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">justify-content</span>: flex-end;  <span class="hljs-attribute">align-items</span>: stretch;&#125;<span class="hljs-selector-class">.nav-section</span> <span class="hljs-selector-class">.slider-button</span> &#123;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">width</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">10px</span>;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;  <span class="hljs-attribute">text-decoration</span>: none;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;&#125;</code></pre><p>Call child component from parent component.</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-image-slider</span> [<span class="hljs-attr">sliders</span>]=<span class="hljs-string">"imagesSliders"</span> #<span class="hljs-attr">imageSlider</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-image-slider</span>&gt;</span></code></pre><p>The Reference name <code>#imageSlider</code> same as in the ts file <code>@ViewChild</code>.</p><p>We can safely use <code>@ViewChild</code> referenced element in <code>ngAfterViewInit</code>.</p><pre><code class="hljs ts"><span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">'imageSlider'</span>, &#123; <span class="hljs-keyword">static</span>: <span class="hljs-literal">true</span> &#125;) imgSlider: ImageSliderComponent;<span class="hljs-comment">// @ViewChild(ImageSliderComponent) imgSlider: ImageSliderComponent;</span>imagesSliders: ImageSlider[] = [    &#123;      imgUrl:        <span class="hljs-string">'https://xxx'</span>,      link: <span class="hljs-string">''</span>,      caption: <span class="hljs-string">''</span>    &#125;,]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Angular 8: Setup and Binding</title>
    <link href="/2019/08/21/Angular-8-setup-and-binding/"/>
    <url>/2019/08/21/Angular-8-setup-and-binding/</url>
    
    <content type="html"><![CDATA[<!-- # Angular 8: setup and binding --><p> Angular 8 Demo Project Log and Experience Part 1. </p><p>This is a log for a Angular Demo project. Through this project, it’s a good chance to review the Angular concept and learn deeper.</p><p>This part 1 focus on the basic concept about binding:</p><ul><li>data binding </li><li>event binding</li><li>template binding</li><li>@Input (property binding)</li><li>@Output (event binding)</li></ul><h2 id="Step-1-Create-new-project"><a href="#Step-1-Create-new-project" class="headerlink" title="Step 1: Create new project"></a>Step 1: Create new project</h2><p><code>ng new my-app</code></p><h2 id="Step-2-Init-AppComponent"><a href="#Step-2-Init-AppComponent" class="headerlink" title="Step 2: Init AppComponent"></a>Step 2: Init AppComponent</h2><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> TopMenu &#123;  title: <span class="hljs-built_in">string</span>;  readonly link?: <span class="hljs-built_in">string</span>;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent &#123;  title = <span class="hljs-string">'App title'</span>;  menus: TopMenu[] = [&#123; title: <span class="hljs-string">'HOT'</span>, link: <span class="hljs-string">''</span> &#125;, &#123; title: <span class="hljs-string">'TOY'</span>, link: <span class="hljs-string">''</span> &#125;];&#125;</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let menu of menus"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span> &#123;&#123;menu.title&#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre><p>To let the menus layout as a flat menu, need to use css to config. The main setting is <code>flex-direction</code> and <code>white-space</code>.</p><p>To avoid the scrollbar in the top menus, use <code>::-webkit-scrollbar</code>.</p><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> &#123;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">flex-direction</span>: row;&#125;<span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;  <span class="hljs-attribute">display</span>: inline-block;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">5px</span>;  <span class="hljs-attribute">white-space</span>: nowrap;&#125;<span class="hljs-selector-tag">a</span> &#123;  <span class="hljs-attribute">text-decoration</span>: none;&#125;<span class="hljs-selector-pseudo">::-webkit-scrollbar</span> &#123;  <span class="hljs-attribute">display</span>: none;&#125;</code></pre><h2 id="Step-3-ngFor-and-ngIf-data-binding-and-event-binding"><a href="#Step-3-ngFor-and-ngIf-data-binding-and-event-binding" class="headerlink" title="Step 3: ngFor and ngIf, data binding and event binding"></a>Step 3: ngFor and ngIf, data binding and event binding</h2><h3 id="ngFor"><a href="#ngFor" class="headerlink" title="*ngFor"></a>*ngFor</h3><ul><li>Syntax: <code>let menu of menus</code></li><li>Get Index: <code>let menu of menus; let i = index</code></li><li>Get First or Last Element: <code>let menu of menus; let first = first; let last = last</code></li><li>Get Even or Odd Elements: <code>let menu of menus; let odd = odd; let even = even</code></li><li>Improve performance: <code>let menu of menus; trackBy: trackElement</code></li><li>Data Binding: [], e.g. <code>[class.active]=&quot;i === selectedIndex&quot;</code></li><li>Event Binding: (), e.g. <code>(click)=&quot;handleSelection(i)&quot;</code></li></ul><h3 id="ngIf"><a href="#ngIf" class="headerlink" title="*ngIf"></a>*ngIf</h3><p>syntax 1:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"condition"</span>&gt;</span>View exposed when the condition is true.<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>syntax 2:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"condition else elseContent"</span>&gt;</span>  Content exposed when the condition is true.<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> #<span class="hljs-attr">elseContent</span></span><span class="hljs-tag">  &gt;</span>Content exposed when the condition is false.<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span></span><span class="hljs-tag">&gt;</span></code></pre><p>syntax 3:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"condition; then thenTemplate; else elseContent"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> #<span class="hljs-attr">thenContent</span></span><span class="hljs-tag">  &gt;</span>Content exposed when the condition is true.<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span></span><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> #<span class="hljs-attr">elseContent</span></span><span class="hljs-tag">  &gt;</span>Content exposed when the condition is false.<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span></span><span class="hljs-tag">&gt;</span></code></pre><h3 id="Modify-the-clicked-item-style"><a href="#Modify-the-clicked-item-style" class="headerlink" title="Modify the clicked item style"></a>Modify the clicked item style</h3><p>When the index is selected, use the active css style. How to monitor the index is selected? Use the event binding, <code>(onclick)</code> to handle the selection, this function pass the index as a parameter.</p><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let menu of menus"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span></span><span class="hljs-tag">    [<span class="hljs-attr">class.active</span>]=<span class="hljs-string">"i === selectedIndex"</span></span><span class="hljs-tag">    (<span class="hljs-attr">click</span>)=<span class="hljs-string">"handleSelection(i)"</span></span><span class="hljs-tag">    &gt;</span> &#123;&#123;menu.title&#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre><pre><code class="hljs css"><span class="hljs-selector-class">.active</span> &#123;  <span class="hljs-attribute">color</span>: red;&#125;</code></pre><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent &#123;  selectedId = <span class="hljs-number">-1</span>;  handleSelection(index: <span class="hljs-built_in">number</span>) &#123;    <span class="hljs-keyword">this</span>.selectedIndex = index;    <span class="hljs-keyword">this</span>.tabSelected.emit(<span class="hljs-keyword">this</span>.menus[<span class="hljs-keyword">this</span>.selectedIndex]);  &#125;&#125;</code></pre><p>To improve the ngFor, we can add:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span></span><span class="hljs-tag">  *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let menu of menus; let i = index; trackBy: menu ? menu.title : null"</span></span><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></code></pre><h2 id="Step-4-Refactor-Component-create-ScrollableTabComponent"><a href="#Step-4-Refactor-Component-create-ScrollableTabComponent" class="headerlink" title="Step 4: Refactor Component: create ScrollableTabComponent"></a>Step 4: Refactor Component: create ScrollableTabComponent</h2><p>To make the logic clearly, move the logic codes from AppComponent to ScrollableTabComponent, chang the AppComponent to call the ScrollableTabComponent.</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-scrollable-tab</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-scrollable-tab</span>&gt;</span></code></pre><p>Remember to add ScrollableTabComponent to the <code>app.module.ts</code> in <code>imports</code> array.</p><h2 id="Step-5-add-feature-in-ScrollableTabComponent"><a href="#Step-5-add-feature-in-ScrollableTabComponent" class="headerlink" title="Step 5: add feature in ScrollableTabComponent"></a>Step 5: add feature in ScrollableTabComponent</h2><p>We can use <code>ngStyle</code> to define the style in html.</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span></span><span class="hljs-tag">    <span class="hljs-attr">class</span>=<span class="hljs-string">"indicator"</span></span><span class="hljs-tag">    [<span class="hljs-attr">ngStyle</span>]=<span class="hljs-string">"&#123; 'background-color': indicatorColor &#125;"</span></span><span class="hljs-tag">    *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"menu.link === selectedTabLink else elseTemplate"</span></span><span class="hljs-tag">  &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> #<span class="hljs-attr">elseTemplate</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Just test<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span></code></pre><pre><code class="hljs css"><span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span> &#123;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">flex-direction</span>: column;  <span class="hljs-attribute">justify-content</span>: space-between;  <span class="hljs-attribute">align-content</span>: center;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">5px</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">white-space</span>: nowrap;&#125;<span class="hljs-selector-class">.indicator</span> &#123;  <span class="hljs-comment">/* background-color: brown; */</span>  <span class="hljs-attribute">height</span>: <span class="hljs-number">2px</span>;  <span class="hljs-comment">/* width: 2rem; */</span>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">2px</span>;&#125;</code></pre><h3 id="Template-Binding"><a href="#Template-Binding" class="headerlink" title="Template Binding"></a>Template Binding</h3><p>Several ways to realize Template Binding:</p><ul><li><pre><code class="hljs ts">&lt;div [<span class="hljs-keyword">class</span>.className]=<span class="hljs-string">"condition"</span>&gt;...&lt;<span class="hljs-regexp">/div&gt;</span></code></pre></li><li><pre><code class="hljs ts">&lt;div [ngClass]=<span class="hljs-string">"&#123;'One': true, 'Two': true, 'Three': false&#125;"</span>&gt;...&lt;<span class="hljs-regexp">/div&gt;</span></code></pre></li><li><pre><code class="hljs ts">&lt;div [ngStyle]=<span class="hljs-string">"&#123;'color':someColor, 'font-size':fontSize&#125;"</span>&gt;...&lt;<span class="hljs-regexp">/div&gt;</span></code></pre><p>For example, we want to set background color, font color, font weight from upper component, then we can code like this.</p><p>In <code>scollable-tab.component.html</code>, we add <code>[ngStyle]=&quot;{ &#39;background-color&#39;: backgroundColor }</code> in tag <code>&lt;ul&gt;</code> to set the background color of the list. And backgroundColor is the input variable from father component.</p></li></ul><h3 id="Input-property-binding-and-Output-event-binding"><a href="#Input-property-binding-and-Output-event-binding" class="headerlink" title="@Input (property binding) and @Output (event binding)"></a>@Input (property binding) and @Output (event binding)</h3><p>Use <code>@Input</code> and <code>@Output</code> to decorate the property and event.</p><p><strong>The <code>@Input</code> decorator indicates that the property value will be passed in from the component’s parent (in this case, the product list component).</strong></p><p><strong>Define a property named tabSelected with an <code>@Output</code> decorator and an instance of event emitter. This makes it possible for the product alert component to emit an event when the value of the notify property changes.</strong></p><p>We have created a menu in <code>ScrollableTabComponent</code>, we want to reuse it somewhere. So, we add a decorator <code>@Input</code> before the menu, indicating the data of this menu field is set by father component.</p><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ScrollableTabComponent &#123;  <span class="hljs-meta">@Input</span>() selectedTabLink: <span class="hljs-built_in">string</span>;  <span class="hljs-meta">@Input</span>() menus: TopMenu[] = [];  <span class="hljs-meta">@Input</span>() backgroundColor = <span class="hljs-string">'#fff'</span>;  <span class="hljs-meta">@Input</span>() titleActiveColor = <span class="hljs-string">'yellow'</span>;  <span class="hljs-meta">@Input</span>() titleColor = <span class="hljs-string">'blue'</span>;  <span class="hljs-meta">@Input</span>() indicatorColor = <span class="hljs-string">'brown'</span>;  <span class="hljs-meta">@Output</span>() tabSelected = <span class="hljs-keyword">new</span> EventEmitter();  handleSelection(index: <span class="hljs-built_in">number</span>) &#123;    <span class="hljs-keyword">this</span>.selectIndex = index;    <span class="hljs-keyword">this</span>.tabSelected.emit(<span class="hljs-keyword">this</span>.menus[index]);  &#125;&#125;</code></pre><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> [<span class="hljs-attr">ngStyle</span>]=<span class="hljs-string">"&#123; 'background-color': backgroundColor &#125;"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let menu of menus; let i = index"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span></span><span class="hljs-tag">      [<span class="hljs-attr">ngStyle</span>]=<span class="hljs-string">"&#123; color: i === selectIndex ? titleActiveColor : titleColor &#125;"</span></span><span class="hljs-tag">      (<span class="hljs-attr">click</span>)=<span class="hljs-string">"handleSelection(i)"</span></span><span class="hljs-tag">    &gt;</span>      &#123;&#123; menu.title &#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span></span><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">"indicator"</span></span><span class="hljs-tag">      [<span class="hljs-attr">ngStyle</span>]=<span class="hljs-string">"&#123; 'background-color': indicatorColor &#125;"</span></span><span class="hljs-tag">      *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"menu.link === selectedTabLink"</span></span><span class="hljs-tag">    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre><p>Call the child component in parent component. Use all the bindings:</p><ul><li>Template Binding</li><li>Property Binding</li><li>Event Binding</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">app-scrollable-tab</span></span><span class="hljs-tag">  [<span class="hljs-attr">menus</span>]=<span class="hljs-string">"topMenus$ | async"</span></span><span class="hljs-tag">  (<span class="hljs-attr">tabSelected</span>)=<span class="hljs-string">"handleTabSelected($event)"</span></span><span class="hljs-tag">  [<span class="hljs-attr">backgroundColor</span>]=<span class="hljs-string">"'#fff'"</span></span><span class="hljs-tag">  <span class="hljs-attr">titleColor</span>=<span class="hljs-string">"#3f3f3f"</span></span><span class="hljs-tag">  <span class="hljs-attr">titleActiveColor</span>=<span class="hljs-string">"red"</span></span><span class="hljs-tag">  <span class="hljs-attr">indicatorColor</span>=<span class="hljs-string">"red"</span></span><span class="hljs-tag">  [<span class="hljs-attr">selectedTabLink</span>]=<span class="hljs-string">"selectedTabLink$ | async"</span></span><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-scrollable-tab</span>&gt;</span></code></pre><pre><code class="hljs ts">handleTabSelected(topMenu: TopMenu) &#123;   <span class="hljs-comment">// this.router.navigate(['home', topMenu.link]);</span>   <span class="hljs-built_in">console</span>.log(topMenu); &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 8 Functional Programming Review</title>
    <link href="/2019/05/29/Java-8-Functional-Programming-Review/"/>
    <url>/2019/05/29/Java-8-Functional-Programming-Review/</url>
    
    <content type="html"><![CDATA[<!-- # Java 8 Functional Programming Review --><h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><p><strong>Functional programming</strong> is a <strong>programming</strong> paradigm - a style of building the structure and elements of computer programs.</p><p>The flag that you handle function programming: Familiar to use <strong>Stream API</strong> and <strong>lambda expressions</strong>, keep the <strong>stream</strong> idea in mind and use the idea in coding work. </p><p>Imperative programming: focus on <strong>HOW</strong> to do: you must tell the detail steps to describe how to make the work done.</p><p>Functional programming: focus on <strong>WHAT</strong> to do: tell Java what you need.</p><h2 id="Lambda-return-an-new-instance-of-a-specific-type"><a href="#Lambda-return-an-new-instance-of-a-specific-type" class="headerlink" title="Lambda return an new instance of a specific type"></a>Lambda return an new instance of a specific type</h2><p>Consider the following equal codes in imperative and functional programming:</p><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"Imperative programming"</span>);  &#125;&#125;).start();</code></pre><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(() -&gt; System.out.println(<span class="hljs-string">"Functional programming"</span>)).start();</code></pre><p>If we refactor these code, there will be</p><pre><code class="hljs java">Runnable target =    <span class="hljs-keyword">new</span> Runnable() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"Imperative programming"</span>);      &#125;    &#125;;<span class="hljs-keyword">new</span> Thread(target).start();</code></pre><pre><code class="hljs java">Runnable target1 = () -&gt; System.out.println(<span class="hljs-string">"Functional programming"</span>);<span class="hljs-keyword">new</span> Thread(target1).start();</code></pre><p>Or, you can create a object instance to hold the value returned by the lambda.</p><pre><code class="hljs java">Object target1 = (Runnable) () -&gt; System.out.println(<span class="hljs-string">"Functional programming"</span>);   <span class="hljs-keyword">new</span> Thread((Runnable) target1).start();</code></pre><p>The lambda return a new instance of a specific type : Runnable object name target1.</p><h2 id="JDK8-new-feature-default-method-in-Interface"><a href="#JDK8-new-feature-default-method-in-Interface" class="headerlink" title="JDK8 new feature: default method in Interface"></a>JDK8 new feature: default method in Interface</h2><p>The annotation <strong>@FunctionalInterface</strong> is default annotation(you can emit), but highly recommend to put this annotation above the interface. That can remind you.</p><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceDemo</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">doubleNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;  <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;    <span class="hljs-keyword">return</span> x + y;  &#125;&#125;</code></pre><h2 id="Different-expression-of-lambda"><a href="#Different-expression-of-lambda" class="headerlink" title="Different expression of lambda"></a>Different expression of lambda</h2><pre><code class="hljs java"><span class="hljs-comment">// with brackets in variable    </span>InterfaceDemo i1 = (i) -&gt; i * <span class="hljs-number">2</span>;   <span class="hljs-comment">// most common expression</span>   InterfaceDemo i2 = i -&gt; i * <span class="hljs-number">2</span>;<span class="hljs-comment">// with type declairtion </span>   InteInterfaceDemorface1 i3 = (<span class="hljs-keyword">int</span> i) -&gt; i * <span class="hljs-number">2</span>;<span class="hljs-comment">// expression way</span>   InterfaceDemo i4 =       (<span class="hljs-keyword">int</span> i) -&gt; &#123;         <span class="hljs-keyword">return</span> i * <span class="hljs-number">2</span>;       &#125;;</code></pre><h2 id="Important-function-interface"><a href="#Important-function-interface" class="headerlink" title="Important function interface"></a>Important function interface</h2><h3 id="Function-lt-T-R-gt"><a href="#Function-lt-T-R-gt" class="headerlink" title="Function&lt;T, R&gt;"></a>Function&lt;T, R&gt;</h3><p>Example 1:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMoneyFormat</span> </span>&#123;  <span class="hljs-function">String <span class="hljs-title">format</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMoney</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> money;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyMoney</span><span class="hljs-params">(<span class="hljs-keyword">int</span> money)</span> </span>&#123;    <span class="hljs-keyword">this</span>.money = money;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMoney</span><span class="hljs-params">(IMoneyFormat moneyFormat)</span> </span>&#123;    System.out.println(<span class="hljs-string">"My Saving: "</span> + moneyFormat.format(<span class="hljs-keyword">this</span>.money));  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionInterfaceDemo</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    MyMoney mm = <span class="hljs-keyword">new</span> MyMoney(<span class="hljs-number">9999999</span>);    mm.printMoney(i -&gt; <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">"#,###"</span>).format(i));  &#125;&#125;</code></pre><p>Example 1 output is: <code>My Saving: 9,999,999</code>.</p><p>The lambda does not care about the interface’s detail or name. It only concern about the input and output. In example 1, the lambda only need to know the input is an <strong>int</strong>,  the return value is a <strong>String</strong>.</p><p>Base on this, we can refactor the printMoney function to example 2:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMoney</span><span class="hljs-params">(Function&lt;Integer, String&gt; moneyFormat)</span> </span>&#123;  System.out.println(<span class="hljs-string">"My Saving: "</span> + moneyFormat.apply(<span class="hljs-keyword">this</span>.money));&#125;</code></pre><p>in example 2, we now can delete the interface IMoneyFormat, instead, we can use Function interface which JDK8 provided. The Function interface can support Chain calls.</p><pre><code class="hljs java">  MyMoney mm = <span class="hljs-keyword">new</span> MyMoney(<span class="hljs-number">9999999</span>);  Function&lt;Integer, String&gt; moneyFormat = i -&gt; <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">"#,###"</span>).format(i);  <span class="hljs-comment">// Function interface chain calls</span>  mm.printMoney(moneyFormat.andThen(s -&gt; <span class="hljs-string">"CAD "</span> + s));&#125;</code></pre><p>The output is <code>My Saving: CAD 9,999,999</code>.</p><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><pre><code class="hljs java"><span class="hljs-comment">// Predicate interface</span> Predicate&lt;Integer&gt; predicate = i -&gt; i &gt; <span class="hljs-number">0</span>; System.out.println(predicate.test(-<span class="hljs-number">9</span>)); IntPredicate predicate1 = i -&gt; i &gt; <span class="hljs-number">0</span>; System.out.println(predicate1.test(-<span class="hljs-number">8</span>));</code></pre><p>The output is </p><pre><code class="hljs plain">falsefalse</code></pre><p>The best practice is use IntPredicate.</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><pre><code class="hljs java"><span class="hljs-comment">// Consumer interface</span>Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);   consumer.accept(<span class="hljs-string">"Input data"</span>);</code></pre><h2 id="Method-References"><a href="#Method-References" class="headerlink" title="Method References"></a>Method References</h2><p>The code </p><pre><code class="hljs java">Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);</code></pre><p>can refactor to a method reference way:</p><pre><code class="hljs java">Consumer&lt;String&gt; consumer = System.out::println;</code></pre><h3 id="Reference-to-a-static-method"><a href="#Reference-to-a-static-method" class="headerlink" title="Reference to a static method"></a>Reference to a static method</h3><p>The format is <code>ContainingClass::staticMethodName</code>.</p><p>For example:</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> </span>&#123;  <span class="hljs-keyword">private</span> String name = <span class="hljs-string">"Andrew"</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bark</span><span class="hljs-params">(Dog dog)</span> </span>&#123;    System.out.println(dog + <span class="hljs-string">" is barking."</span>);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;  &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodRefrenceDemo</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// Reference to a static method</span>    Consumer&lt;Dog&gt; consumer1 = Dog::bark;    Dog dog = <span class="hljs-keyword">new</span> Dog();    consumer1.accept(dog);  &#125;&#125;</code></pre><p>The output is: <code>Andrew is barking.</code></p><h3 id="Reference-to-an-instance-method-of-a-particular-object"><a href="#Reference-to-an-instance-method-of-a-particular-object" class="headerlink" title="Reference to an instance method of a particular object"></a>Reference to an instance method of a particular object</h3><p>The calling format is <code>containingObject::instanceMethodName</code>.</p><p>Add a non-static method in class Dog.</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;  System.out.println(<span class="hljs-string">"eat "</span> + num + <span class="hljs-string">" kg food."</span>);  <span class="hljs-keyword">this</span>.food -= num;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.food;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">// Reference to an instance method of a particular object</span>   Function&lt;Integer,Integer&gt; function = dog::eat;   System.out.println(<span class="hljs-string">"left "</span> + function.apply(<span class="hljs-number">2</span>)+<span class="hljs-string">" kg"</span>);</code></pre><p>The output is:</p><pre><code class="hljs powershell">eat <span class="hljs-number">2</span> kg food.left <span class="hljs-number">8</span> kg</code></pre><p>The function input and output type is the same, can refactor to:</p><pre><code class="hljs java">UnaryOperator&lt;Integer&gt; function = dog::eat;</code></pre><p>Further, refactor to:</p><pre><code class="hljs java">IntUnaryOperator function = dog::eat;System.out.println(<span class="hljs-string">"left "</span> + function.applyAsInt(<span class="hljs-number">2</span>)+<span class="hljs-string">" kg"</span>);</code></pre><h3 id="Reference-to-an-instance-method-of-an-arbitrary-object-of-a-particular-type-Class-Name-Method-Reference"><a href="#Reference-to-an-instance-method-of-an-arbitrary-object-of-a-particular-type-Class-Name-Method-Reference" class="headerlink" title="Reference to an instance method of an arbitrary object of a particular type (Class Name Method Reference)"></a>Reference to an instance method of an arbitrary object of a particular type (Class Name Method Reference)</h3><pre><code class="hljs java"><span class="hljs-comment">// Class Name Method Reference</span>   BiFunction&lt;Dog, Integer, Integer&gt; eatFunction = Dog::eat;   System.out.println(<span class="hljs-string">"left "</span> + eatFunction.apply(dog, <span class="hljs-number">2</span>) + <span class="hljs-string">" kg."</span>);</code></pre><h3 id="Reference-to-a-constructor"><a href="#Reference-to-a-constructor" class="headerlink" title="Reference to a constructor"></a>Reference to a constructor</h3><pre><code class="hljs java"><span class="hljs-comment">// Reference to a constructor</span>Supplier&lt;Dog&gt; supplier = Dog::<span class="hljs-keyword">new</span>;System.out.println(<span class="hljs-string">"Create a new object: "</span> + supplier.get());</code></pre><pre><code class="hljs java"><span class="hljs-comment">// Reference to a constructor with parameter</span>Function&lt;String, Dog&gt; function1 = Dog::<span class="hljs-keyword">new</span>;System.out.println(<span class="hljs-string">"Create a new object: "</span> + function1.apply(<span class="hljs-string">"New Dog"</span>));</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Component - The Angular Key concept</title>
    <link href="/2019/03/07/Component-The-Angular-Key-concept/"/>
    <url>/2019/03/07/Component-The-Angular-Key-concept/</url>
    
    <content type="html"><![CDATA[<!-- # Component - The Angular Key concept --><h2 id="The-basic-role-of-Component-Module-and-Router"><a href="#The-basic-role-of-Component-Module-and-Router" class="headerlink" title="The basic role of Component, Module and Router"></a>The basic role of Component, Module and Router</h2><h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><p>Component is the key of Angular, and is the core goal of the whole framework. The component can encapsulate the logic inside the component. The encapsulated component can reuse, no matter inside the project or other projects.</p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>NgModule is the best way to organize the business code. Base on different scenario, package the components, services and routers to a independent module. The module like a piece of building blcok, which can build the whole building.</p><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>There are 3 duties of router:</p><ol><li>enables navigation from one view to the next as users perform application tasks.</li><li>load the Async module.</li><li>manage the life circle of component.</li></ol><h2 id="The-Component-template"><a href="#The-Component-template" class="headerlink" title="The Component template"></a>The Component template</h2><p>The component template is the most important part of Angualr. We need to understand the following points:</p><h3 id="The-idea-of-Angular-Logic-less"><a href="#The-idea-of-Angular-Logic-less" class="headerlink" title="The idea of Angular: Logic-less"></a>The idea of Angular: Logic-less</h3><p>Logic-less means <strong>DO NOT</strong> write complex JavaScript expressions in the template. The reason is that the template will be excute many times, the complex will effect the performance.</p><p>That’s why the Angular offical site says:</p><blockquote><p>You can’t use JavaScript expressions that have or promote side effects, including:</p><ul><li>Assignments (=, +=, -=, …)</li><li>Operators such as new, typeof, instanceof, etc.</li><li>Chaining expressions with ; or ,</li><li>The increment and decrement operators ++ and –</li><li>Some of the ES2015+ operators</li></ul><p>Other notable differences from JavaScript syntax include:</p><ul><li>No support for the bitwise operators such as | and &amp;</li><li>New template expression operators, such as |, ?. and !</li></ul></blockquote><p>Like this Angular template</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let race of races"</span>&gt;</span>    &#123;&#123;race.name&#125;&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></code></pre><p>The browser doesn’t know the sytax of <code>*ngFor</code> and <code></code>. Thus there must be a ‘compile’ operation in the browser to get the template function, then pass the date to the funxtion, and combine with the html tags, finally insert all these to the DOM tree.</p><p>There is another reason why Angular use Logic-less: in the whole life cycle of component, the template function will be excuted many time.</p><h3 id="Mustache-Syntax-…"><a href="#Mustache-Syntax-…" class="headerlink" title="Mustache Syntax "></a>Mustache Syntax </h3><p>The Mustache Syntax  can do the following:</p><ol><li>Interpolation: embedding expressions into marked up text. Means insert the value to this place.</li><li>Template expressions: produces a value and appears within the double curly braces.</li><li>Get the return value of the funciton which is defined in the component.</li></ol><h3 id="Binding-syntax"><a href="#Binding-syntax" class="headerlink" title="Binding syntax"></a>Binding syntax</h3><h4 id="Property-Binding"><a href="#Property-Binding" class="headerlink" title="Property Binding"></a>Property Binding</h4><p>It is One-way from data source to view target. Use [].</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"imgSrc"</span> /&gt;</span></code></pre><pre><code class="hljs javascript">public imgSrc:string=<span class="hljs-string">"./assets/imgs/1.jpg"</span>;</code></pre><h4 id="Event-Binding"><a href="#Event-Binding" class="headerlink" title="Event Binding"></a>Event Binding</h4><p>It is One-way from view target to data source. Use ().</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn‐success"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"btnClick($event)"</span>&gt;</span>  Test event<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre><pre><code class="hljs js">public btnClick(event):<span class="hljs-keyword">void</span>&#123; alert(<span class="hljs-string">"Test Event Binding！"</span>); &#125;</code></pre><h4 id="Two-way-Binding"><a href="#Two-way-Binding" class="headerlink" title="Two-way Binding"></a>Two-way Binding</h4><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">font‐resizer</span> [(<span class="hljs-attr">size</span>)]=<span class="hljs-string">"fontSizePx"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">font‐resizer</span>&gt;</span></code></pre><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> fontSizePx:<span class="hljs-built_in">number</span>=<span class="hljs-number">14</span>;</code></pre><h3 id="Structural-Directives"><a href="#Structural-Directives" class="headerlink" title="Structural Directives"></a>Structural Directives</h3><p>There are 3 Structural directives: <strong>*ngIf</strong>, <strong>*ngFor</strong> and <strong>ngSwitch</strong>.</p><h4 id="ngIf-code-example"><a href="#ngIf-code-example" class="headerlink" title="*ngIf code example"></a>*ngIf code example</h4><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"isShow"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background‐color:#ff3300"</span>&gt;</span>Show or not?<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn‐success"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"toggleShow()"</span>&gt;</span>Control visiable<span class="hljs-tag">&lt;/<span class="hljs-name">butto</span></span><span class="hljs-tag"><span class="hljs-attr">n</span>&gt;</span></code></pre><pre><code class="hljs ts"><span class="hljs-keyword">public</span> isShow:<span class="hljs-built_in">boolean</span>=<span class="hljs-literal">true</span>;<span class="hljs-keyword">public</span> toggleShow():<span class="hljs-built_in">void</span>&#123;<span class="hljs-keyword">this</span>.isShow=!<span class="hljs-keyword">this</span>.isShow;&#125;</code></pre><h4 id="ngFor-code-example"><a href="#ngFor-code-example" class="headerlink" title="*ngFor code example"></a>*ngFor code example</h4><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let race of races;let i=index;"</span>&gt;</span>  &#123;&#123;i+1&#125;&#125;‐&#123;&#123;race.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></code></pre><pre><code class="hljs ts"><span class="hljs-keyword">public</span> races:<span class="hljs-built_in">Array</span>=[ &#123;name:<span class="hljs-string">"human"</span>&#125;, &#123;name:<span class="hljs-string">"animal"</span>&#125;, &#123;name:<span class="hljs-string">"other"</span>&#125; ];</code></pre><blockquote><p>Structural directives are responsible for HTML layout. They shape or reshape the DOM’s structure, typically by adding, removing, or manipulating elements.</p></blockquote><p><strong>A Html tag can ONLY use ONE Structural Directives in the same time.</strong></p><h3 id="Built-in-attribute-directives"><a href="#Built-in-attribute-directives" class="headerlink" title="Built-in attribute directives"></a>Built-in attribute directives</h3><blockquote><p>Attribute directives listen to and modify the behavior of other HTML elements, attributes, properties, and components. They are usually applied to elements as if they were HTML attributes, hence the name.</p><ul><li>NgClass - add and remove a set of CSS classes</li><li>NgStyle - add and remove a set of HTML styles</li><li>NgModel - two-way data binding to an HTML form element</li></ul></blockquote><h4 id="ngClass-code-example"><a href="#ngClass-code-example" class="headerlink" title="*ngClass code example"></a>*ngClass code example</h4><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> [<span class="hljs-attr">ngClass</span>]=<span class="hljs-string">"currentClasses"</span>&gt;</span>a set of CSS classes<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn‐success"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"setCurrentClasses()"</span>&gt;</span>Set<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre><pre><code class="hljs ts"><span class="hljs-keyword">public</span> currentClasses: &#123;&#125;;<span class="hljs-keyword">public</span> canSave: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;<span class="hljs-keyword">public</span> isUnchanged: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;<span class="hljs-number">5</span> <span class="hljs-keyword">public</span> isSpecial: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;setCurrentClasses() &#123;<span class="hljs-keyword">this</span>.currentClasses = &#123;<span class="hljs-string">'saveable'</span>: <span class="hljs-keyword">this</span>.canSave,<span class="hljs-string">'modified'</span>: <span class="hljs-keyword">this</span>.isUnchanged,<span class="hljs-string">'special'</span>: <span class="hljs-keyword">this</span>.isSpecial&#125;;&#125;</code></pre><pre><code class="hljs css"><span class="hljs-selector-class">.saveable</span> &#123;  font‐size: 18px;&#125;<span class="hljs-selector-class">.modified</span> &#123;  font‐weight: bold;&#125;<span class="hljs-selector-class">.special</span> &#123;  background‐color: #ff3300;&#125;</code></pre><h4 id="Avoid-to-use-ngStyle"><a href="#Avoid-to-use-ngStyle" class="headerlink" title="Avoid to use ngStyle"></a><strong>Avoid to use ngStyle</strong></h4><p>ngStyle write CSS style inside the code, avoid to use it. It’s a bad way to code.</p>]]></content>
    
    
    <categories>
      
      <category>Angular</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Angular</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Simple Spring Boot Error: jdbc driver update</title>
    <link href="/2019/03/06/Simple-Spring-Boot-Error-jdbc-driver-update/"/>
    <url>/2019/03/06/Simple-Spring-Boot-Error-jdbc-driver-update/</url>
    
    <content type="html"><![CDATA[<!-- # Simple Spring Boot Error: jdbc driver update --><p> A collection of simple Spring Boot Error</p><h2 id="JDBC-driver"><a href="#JDBC-driver" class="headerlink" title="JDBC driver"></a>JDBC driver</h2><h3 id="Error-tips"><a href="#Error-tips" class="headerlink" title="Error tips:"></a>Error tips:</h3><p><code>org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration&#39;</code></p><h3 id="Whole-error-tips"><a href="#Whole-error-tips" class="headerlink" title="Whole error tips:"></a>Whole error tips:</h3><pre><code class="hljs shell">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration': Unsatisfied dependency expressed through constructor parameter 0;nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSource' defined in class path resource [org/springframework/boot/autoconfigure/jdbc/DataSourceConfiguration$Tomcat.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.tomcat.jdbc.pool.DataSource]: Factory method 'dataSource' threw exception; nested exception is java.lang.IllegalStateException: Cannot load driver class: com.mysql.cj.jdbc.Driver</code></pre><h3 id="Reason"><a href="#Reason" class="headerlink" title="Reason"></a>Reason</h3><p>Can not relize <code>com.mysql.cj.jdbc.Driver</code>.</p><h3 id="Fix"><a href="#Fix" class="headerlink" title="Fix"></a>Fix</h3><p>Change <code>spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver</code> to <code>spring.datasource.driverClassName=com.mysql.jdbc.Driver</code>.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
